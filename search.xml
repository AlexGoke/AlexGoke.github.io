<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[HTTP错误码302解决办法]]></title>
    <url>%2F2019%2F01%2F09%2FHTTP%E9%94%99%E8%AF%AF%E7%A0%81302%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[HTTP错误码302解决办法问题描述在制作网站的登录系统时，经测试发现，无法成功的从主页登录至个人页面，返回结果的HTTP状态码如下：12127.0.0.1 - - [09/Jan/2019 09:08:31] "GET /index HTTP/1.1" 302 -127.0.0.1 - - [09/Jan/2019 09:08:31] "GET /login?next=%2Findex HTTP/1.1" 200 - 注：/login为登录页面， /index为成功登录后的个人页面 第一个返回结果表示跳转/index个人页面时，发生了302 Found-临时性重定向。第二个返回结果表示跳转/login登录页面时，发生200 OK, 表示从客户端发来的请求在服务器端被正常处理了。所以又回到了登录页面。 302定义 302 : 302 代表暂时性转移(Temporarily Moved )。该状态码表示请求的资源已被分配了新的URI，希望用户（本次）能使用新的URI访问。 意思就是你访问网址A，但是网址A因为服务器端的拦截器或者其他后端代码处理的原因，会被重定向到网址B。 解决方法我这里出现302错误的原因是由于我的后端代码写了从OpenID获取用户名和邮箱后，==对邮箱email进行验证==，若数据库中不存在该用户，则当作新用户处理，分别将从OpenID中获取的用户名nickname和邮箱email存入数据库。 12345678910111213141516171819202122#登录回调函数@oid.after_logindef after_login(resp): #resp参数传递给after_login()函数，它包含了从OpenID提供商返回来的信息，上面设置需要返回的信息是：nickname, email if resp.email is None or resp.email == "": flash('Invalid login. Please try again.') return redirect(url_for('login')) user = User.query.filter_by(emile=resp.emil).first() #从数据库中搜索邮箱地址 if user is None: #如果用户不存在，说明是一个新用户，添加一个新用户到数据库 nickname = resp.nickname if nickname is None or nickname == "": nickname =resp.email.spilt('@')[0] user = User(nickname = nickname, email = resp.email) db.session.add(user) db.session.commit() remember_me = False if 'remember_me' in session: remember_me = session[ 'remember_me' ] session.pop('remember_me', None) login_user(user, remember = remember_me) #为了注册这个有效的登录，调用Flask-Login的login_user函数 return redirect(request.args.get('next') or url_for('index')) 测试始终不成功，无法成功登录： 从代码逻辑出发考虑：可能是从OpenID获取的数据有问题，也将无法再与数据库进行判断。尝试将判断邮箱改为判断用户名（emil改为nickname）123456789#登录回调函数@oid.after_logindef after_login(resp): if resp.nickname is None or resp.nickname == "": flash('Invalid login. Please try again.') return redirect(url_for('login')) user = User.query.filter_by(nickname=resp.nickname).first() #从数据库中搜索用户名信息………… 测试后成功登录： 说明从OpenID请求发回的数据是没有email信息的，程序逻辑进入了回到登录页/login 为什么从OpenID返回的信息没有email呢？ （还不清楚）]]></content>
      <categories>
        <category>Python</category>
        <category>Flask</category>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>编程</tag>
        <tag>Flask</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python类的继承]]></title>
    <url>%2F2018%2F12%2F23%2Fpython%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[类的继承 总是从某个类继承，如果没有具体父类的话，那么都是从object继承。 class MyClass(object): pass 不要忘记调用super(). init 用来初始化父类的，如果忘记调用，那么父类的属性就可能没有被初始化。 def __init__(self, args): super(SubClass, self).__init__(args) pass python中继承一个类如果已经定义了Person类，需要定义新的Student和Teacher类时，可以直接从Person类继承： 1234class Person(object): def __init__(self, name, gender): self.name = name self.gender = gender 定义Student类时，只需要把额外的属性加上，例如score：1234class Student(Person): def __init__(self, name, gender, score): super(Student, self).__init__(name, gender) self.score = score 一定要用 super(Student, self).init(name, gender) 去初始化父类，否则，继承自 Person 的 Student 将没有 name 和 gender。 函数super(Student, self) 将返回当前类继承的父类，即 Person ，然后调用init()方法，注意self参数已在super()中传入，在init()中将隐式传递，不需要写出（也不能写）。 4.2 python中判断类型函数isinstance()可以判断一个变量的类型，既可以用在Python内置的数据类型如str、list、dict，也可以用在我们自定义的类，它们本质上都是数据类型。假设有如下的 Person、Student 和 Teacher 的定义及继承关系如下：123p = Person('Tim', 'Male')s = Student('Bob', 'Male', 88)t = Teacher('Alice', 'Female', 'English') 当我们拿到变量 p、s、t 时，可以使用 isinstance 判断类型：123456&gt;&gt;&gt; isinstance(p, Person)True # p是Person类型&gt;&gt;&gt; isinstance(p, Student)False # p不是Student类型&gt;&gt;&gt; isinstance(p, Teacher)False # p不是Teacher类型 4.3 python中多态类具有继承关系，并且子类类型可以向上转型看做父类类型，如果我们从 Person 派生出 Student和Teacher ，并都写了一个 whoAmI() 方法：1234567891011121314151617181920class Person(object): def __init__(self, name, gender): self.name = name self.gender = gender def whoAmI(self): return 'I am a Person, my name is %s' % self.nameclass Student(Person): def __init__(self, name, gender, score): super(Student, self).__init__(name, gender) self.score = score def whoAmI(self): return 'I am a Student, my name is %s' % self.nameclass Teacher(Person): def __init__(self, name, gender, course): super(Teacher, self).__init__(name, gender) self.course = course def whoAmI(self): return 'I am a Teacher, my name is %s' % self.name 在一个函数中，如果我们接收一个变量 x，则无论该 x 是 Person、Student还是 Teacher，都可以正确打印出结果：12345678910def who_am_i(x): print x.whoAmI()p = Person('Tim', 'Male')s = Student('Bob', 'Male', 88)t = Teacher('Alice', 'Female', 'English')who_am_i(p)who_am_i(s)who_am_i(t) 运行结果：123I am a Person, my name is TimI am a Student, my name is BobI am a Teacher, my name is Alice 这种行为称为多态。也就是说，方法调用将作用在 x 的实际类型上。s 是Student类型，它实际上拥有自己的 whoAmI() 方法以及从 Person继承的 whoAmI方法，但调用 s.whoAmI() 总是先查找它自身的定义，如果没有定义，则顺着继承链向上查找，直到在某个父类中找到为止。 由于Python是动态语言，所以，传递给函数 who_am_i(x) 的参数 x 不一定是 Person 或 Person 的子类型。任何数据类型的实例都可以，只要它 有一个whoAmI() 的方法即可： 这是动态语言和静态语言（例如Java）最大的差别之一。动态语言调用实例方法，不检查类型，只要方法存在，参数正确，就可以调用。 python中多重继承除了从一个父类继承外，Python允许从多个父类继承，称为多重继承。 多重继承的继承链就不是一棵树了，它像这样：12345678910111213141516171819class A(object): def __init__(self, a): print 'init A...' self.a = aclass B(A): def __init__(self, a): super(B, self).__init__(a) print 'init B...'class C(A): def __init__(self, a): super(C, self).__init__(a) print 'init C...'class D(B, C): def __init__(self, a): super(D, self).__init__(a) print 'init D...' 如图所示： 像这样，D 同时继承自 B 和 C，也就是 D 拥有了 A、B、C 的全部功能。多重继承通过 super() 调用init()方法时，A 虽然被继承了两次，但init()只调用一次：12345&gt;&gt;&gt; d = D('d')init A...init C...init B...init D... 多重继承的目的是从两种继承树中分别选择并继承出子类，以便组合功能使用。 python中获取对象信息拿到一个变量，除了用 isinstance() 判断它是否是某种类型的实例外，还有没有别的方法获取到更多的信息呢？ 首先可以用 type() 函数获取变量的类型，它返回一个 Type 对象：12345&gt;&gt;&gt; type(123)&lt;type 'int'&gt;&gt;&gt;&gt; s = Student('Bob', 'Male', 88)&gt;&gt;&gt; type(s)&lt;class '__main__.Student'&gt; 其次，可以用 dir() 函数获取变量的所有属性：12345&gt;&gt;&gt; dir(123) # 整数也有很多属性...['__abs__', '__add__', '__and__', '__class__', '__cmp__', ...]&gt;&gt;&gt; dir(s)['__class__', '__delattr__', '__dict__', '__doc__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'gender', 'name', 'score', 'whoAmI'] 对于实例变量，dir() 返回所有实例属性，包括__class__这类有特殊意义的属性。注意到方法whoAmI也是 s 的一个属性。 如何去掉__xxx__这类的特殊属性，只保留我们自己定义的属性？回顾一下filter() 函数的用法。 dir() 返回的属性是字符串列表，如果已知一个属性名称，要获取或者设置对象的属性，就需要用 getattr() 和 setattr( ) 函数了：123456789101112131415&gt;&gt;&gt; getattr(s, 'name') # 获取name属性'Bob'&gt;&gt;&gt; setattr(s, 'name', 'Adam') # 设置新的name属性&gt;&gt;&gt; s.name'Adam'&gt;&gt;&gt; getattr(s, 'age') # 获取age属性，但是属性不存在，报错：Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;AttributeError: 'Student' object has no attribute 'age'&gt;&gt;&gt; getattr(s, 'age', 20) # 获取age属性，如果属性不存在，就返回默认值20：20 任务：对于Person类的定义： class Person(object): def __init__(self, name, gender): self.name = name self.gender = gender 希望除了 name和gender 外，可以提供任意额外的关键字参数，并绑定到实例，请修改 Person 的 init()定 义，完成该功能。 传入**kw 即可传入任意数量的参数，并通过 setattr() 绑定属性。123456789class Person(object): def __init__(self, name, gender, **kw): for k, v in kw.iteritems(): setattr(self, k, v)p = Person('Bob', 'Male', age=18, course='Python')print p.ageprint p.course]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python面向对象编程]]></title>
    <url>%2F2018%2F12%2F22%2Fpython%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[面向对象编程python之定义类并创建实例在Python中，类通过 class 关键字定义。12class Person(object): pass 按照 Python 的编程习惯，类名以大写字母开头，紧接着是(object)，表示该类是从哪个类继承下来的。类的继承将在后面的章节讲解，现在我们只需要简单地从object类继承。有了Person类的定义，就可以创建出具体的xiaoming、xiaohong等实例。创建实例使用 类名+()，类似函数调用的形式创建：12xiaoming = Person()xiaohong = Person() python中创建实例属性虽然可以通过Person类创建出xiaoming、xiaohong等实例，但是这些实例看上除了地址不同外，没有什么其他不同。如何让每个实例拥有各自不同的属性？由于Python是动态语言，对每一个实例，都可以直接给他们的属性赋值，例如，给xiaoming这个实例加上name、gender和birth属性：1234xiaoming = Person()xiaoming.name = 'Xiao Ming'xiaoming.gender = 'Male'xiaoming.birth = '1990-1-1' python中初始化实例属性现实世界中，一种类型的实例应该拥有相同名字的属性。在定义 Person 类时，可以为Person类添加一个特殊的init()方法，当创建实例时，init()方法被自动调用，我们就能在此为每个实例都统一加上以下属性：12345class Person(object): def __init__(self, name, gender, birth): self.name = name self.gender = gender self.birth = birth init() 方法的第一个参数必须是 self（也可以用别的名字，但建议使用习惯用法），后续参数则可以自由指定，和定义函数没有任何区别。相应地，创建实例时，就必须要提供除 self 以外的参数：12xiaoming = Person('Xiao Ming', 'Male', '1991-1-1')xiaohong = Person('Xiao Hong', 'Female', '1992-2-2') 有了init()方法，每个Person实例在创建时，都会有 name、gender 和 birth 这3个属性，并且，被赋予不同的属性值，访问属性使用.操作符： 任务：请定义Person类的init方法，除了接受 name、gender 和 birth 外，还可接受任意关键字参数，并把他们都作为属性赋值给实例。 要定义关键字参数，使用 **kw；除了可以直接使用 self.name = ‘xxx’ 设置一个属性外，还可以通过 setattr(self, ‘name’, ‘xxx’) 设置属性。 12345678class Person(object): def __init__(self, name, gender, birth, **kw): self.name = name self.gender = gender self.birth = birth for k, v in kw.iteritems(): setattr(self, k, v)xiaoming = Person('Xiao Ming', 'Male', '1990-1-1', job='Student') python中访问限制 Python对属性权限的控制是通过属性名来实现的，如果一个属性由双下划线开头(__)，该属性就无法被外部访问。[类比C#中 私有变量private] 看例子： 123456789101112 class Person(object): def __init__(self, name): self.name = name self._title = 'Mr' self.__job = 'Student'p = Person('Bob')print p.name =&gt; Bobprint p._title =&gt; Mrprint p.__job =&gt; Error 可见，只有以双下划线开头的 “__job” 不能直接被外部访问。 但是，如果一个属性以xxx 的形式定义，那它又可以被外部访问了，以xxx定义的属性在Python的类中被称为特殊属性，有很多预定义的特殊属性可以使用，通常我们不要把普通属性用xxx定义。 以单下划线开头的属性”_xxx”虽然也可以被外部访问，但是，按照习惯，他们不应该被外部访问。 python中创建类属性 类是模板，而实例则是根据类创建的对象。 绑定在一个实例上的属性不会影响其他实例，但是，类本身也是一个对象，如果在类上绑定一个属性，则所有实例都可以访问类的属性，并且，所有实例访问的类属性都是同一个！也就是说，实例属性每个实例各自拥有，互相独立，而类属性有且只有一份。 定义类属性可以直接在 class 中定义： 1234class Person(object): address = 'Earth' def __init__(self, name): self.name = name 因为类属性是直接绑定在类上的，所以，访问类属性不需要创建实例，就可以直接访问： 12print Person.address=&gt; Earth 对一个实例调用类的属性也是可以访问的，所有实例都可以访问到它所属的类的属性： 由于Python是动态语言，类属性也是可以动态添加和修改的： 12345 Person.address = 'China'print p1.address =&gt; 'China'print p2.address =&gt; 'China' 因为类属性只有一份，所以，当Person类的address改变时，所有实例访问到的类属性都改变了。 任务：请给 Person 类添加一个类属性 count，每创建一个实例，count 属性就加 1，这样就可以统计出一共创建了多少个 Person 的实例。 由于创建实例必定会调用init()方法，所以在这里修改类属性 count 很合适。 12345class Person(object): count = 0 def __init__(self, name): Person.count = Person.count + 1 self.name = name python中类属性和实例属性名字冲突怎么办 修改类属性会导致所有实例访问到的类属性全部都受影响，但是，如果在实例变量上修改类属性会发生什么问题呢？1234567891011121314class Person(object): address = 'Earth' def __init__(self, name): self.name = namep1 = Person('Bob')p2 = Person('Alice')print 'Person.address = ' + Person.addressp1.address = 'China'print 'p1.address = ' + p1.addressprint 'Person.address = ' + Person.addressprint 'p2.address = ' + p2.address 结果如下：1234Person.address = Earthp1.address = ChinaPerson.address = Earthp2.address = Earth 我们发现，在设置了 p1.address = ‘China’ 后，p1访问 address 确实变成了 ‘China’，但是，Person.address和p2.address仍然是’Earch’，怎么回事？原因是 p1.address = ‘China’并没有改变 Person 的 address，而是给 p1这个实例绑定了实例属性address ，对p1来说，它有一个实例属性address（值是’China’），而它所属的类Person也有一个类属性address，所以:访问 p1.address 时，优先查找实例属性，返回’China’。访问 p2.address 时，p2没有实例属性address，但是有类属性address，因此返回’Earth’。可见，当实例属性和类属性重名时，实例属性优先级高，它将屏蔽掉对类属性的访问。可见，千万不要在实例上修改类属性，它实际上并没有修改类属性，而是给实例绑定了一个实例属性。 python中定义实例方法 一个实例的私有属性就是以__开头的属性，无法被外部访问，那这些属性定义有什么用？虽然私有属性无法从外部访问，但是，从类的内部是可以访问的。除了可以定义实例的属性外，还可以定义实例的方法。 实例的方法就是在类中定义的函数，它的第一个参数永远是 self，指向调用该方法的实例本身，其他参数和一个普通函数是完全一样的：1234567class Person(object): def __init__(self, name): self.__name = name def get_name(self): return self.__name get_name(self) 就是一个实例方法，它的第一个参数是self。init (self, name) 其实也可看做是一个特殊的实例方法。 调用实例方法必须在实例上调用：123p1 = Person('Bob')print p1.get_name() # self不需要显式传入=&gt; Bob 在实例方法内部，可以访问所有实例属性，这样，如果外部需要访问私有属性，可以通过方法调用获得，这种数据封装的形式除了能保护内部数据一致性外，还可以简化外部调用的难度。 python中方法也是属性我们在 class 中定义的实例方法其实也是属性，它实际上是一个函数对象：1234567891011121314class Person(object): def __init__(self, name, score): self.name = name self.score = score def get_grade(self): return 'A'p1 = Person('Bob', 90)print p1.get_grade=&gt; &lt;bound method Person.get_grade of &lt;__main__.Person object at 0x109e58510&gt;&gt;print p1.get_grade() =&gt; A p1.get_grade 返回的是一个函数对象，但这个函数是一个绑定到实例的函数，p1.get_grade() 才是方法调用。 因为方法也是一个属性，所以，它也可以动态地添加到实例上，只是需要用 types.MethodType() 把一个函数变为一个方法：(给一个实例动态添加方法并不常见，直接在class中定义要更直观。)——略 python中定义类方法和属性类似，方法也分实例方法和类方法。 在class中定义的全部是实例方法，实例方法第一个参数 self 是实例本身。 要在class中定义类方法，需要这么写：12345678class Person(object): count = 0 @classmethod def how_many(cls): return cls.count def __init__(self, name): self.name = name Person.count = Person.count + 1 通过标记一个 @classmethod，该方法将绑定到 Person 类上，而非类的实例。类方法的第一个参数将传入类本身，通常将参数名命名为 cls，上面的 cls.count 实际上相当于 Person.count。 因为是在类上调用，而非实例上调用，因此类方法无法获得任何实例变量，只能获得类的引用。[类比C#里的静态函数（static function)]]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python模块]]></title>
    <url>%2F2018%2F12%2F22%2Fpython%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[@TOC 模块 模块 和 包 的概念:-将代码放入多个py文件，同一个名字变量互不影响-模块名字就是 py文件的文件名1234&gt; #test.py 自身模块名test&gt; import math 引用math模块&gt; print math.pow(2, 10) 调用math模块的函数&gt; 模块多了以后，也容易重名，解决办法就是放入不同的包1234&gt; # test.py 自身模块名&gt; import p1.util 引用p1.util模块, p1是包&gt; print p1.util.f(2, 10) 调用p1.util模块的f函数&gt; 在文件系统中，包就是文件夹，模块就是XXX.py文件包可以有多级如何去分包和普通目录：包下面有个init.py注意每层包的每层目录都要有这个文件！ python之导入模块要使用一个模块，我们必须首先导入该模块。Python使用import语句导入一个模块。例如，导入系统自带的模块 math：1import math 你可以认为math就是一个指向已导入模块的变量，通过该变量，我们可以访问math模块中所定义的所有公开的函数、变量和类：1234&gt;&gt;&gt; math.pow(2, 0.5) # pow是函数1.4142135623730951&gt;&gt;&gt; math.pi # pi是变量3.141592653589793 如果我们只希望导入用到的math模块的某几个函数，而不是所有函数，可以用下面的语句：1from math import pow, sin, log 如果使用import导入模块名，由于必须通过模块名引用函数名，因此不存在冲突：123import math, loggingprint math.log(10) # 调用的是math的log函数logging.log(10, 'something') # 调用的是logging的log函数 如果使用 from…import 导入 log 函数，势必引起冲突。这时，可以给函数起个“别名”来避免冲突：1234from math import logfrom logging import log as logger # logging的log现在变成了loggerprint log(10) # 调用的是math的loglogger(10, 'import from logging') # 调用的是logging的log python中动态导入模块有的时候，两个不同的模块提供了相同的功能，比如 StringIO 和 cStringIO 都提供了StringIO这个功能。这是因为Python是动态语言，解释执行，因此Python代码运行速度慢。如果要提高Python代码的运行速度，最简单的方法是把某些关键函数用 C 语言重写，这样就能大大提高执行速度。同样的功能，StringIO 是纯Python代码编写的，而 cStringIO 部分函数是 C 写的，因此 cStringIO 运行速度更快。利用ImportError错误，我们经常在Python中动态导入模块：1234try: from cStringIO import StringIOexcept ImportError: from StringIO import StringIO 上述代码先尝试从cStringIO导入，如果失败了（比如cStringIO没有被安装），再尝试从StringIO导入。这样，如果cStringIO模块存在，则我们将获得更快的运行速度，如果cStringIO不存在，则顶多代码运行速度会变慢，但不会影响代码的正常执行。 python之使用futurePython的新版本会引入新的功能，但是，实际上这些功能在上一个老版本中就已经存在了。要“试用”某一新的特性，就可以通过导入future模块的某些功能来实现。Python 2.7的整数除法运算结果仍是整数：Python 3.x已经改进了整数的除法运算，“/”除将得到浮点数，“//”除才仍是整数：1234&gt;&gt;&gt; 10 / 33.3333333333333335&gt;&gt;&gt; 10 // 33 要在Python 2.7中引入3.x的除法规则，导入future的division：123&gt;&gt;&gt; from __future__ import division&gt;&gt;&gt; print 10 / 33.3333333333333335 当新版本的一个特性与旧版本不兼容时，该特性将会在旧版本中添加到future中，以便旧的代码能在旧版本中测试新特性。 python之安装第三方模块 python提供的模块管理工具： easy_install pip （推荐，已内置到python2.7.9）]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python函数式编程]]></title>
    <url>%2F2018%2F12%2F22%2Fpython%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[函数式编程是一种范式，不同于函数把计算视为函数而非指令；纯函数式编程：不需要变量，没有副作用，测试简单；支持高阶函数，代码简洁。 @TOC 函数式编程简介 函数： function函数式：functional，一种编程范式 函数式编程特点：把计算视为函数而非指令；纯函数式编程：不需要变量，没有副作用，测试简单；支持高阶函数，代码简洁 高阶函数变量可以指向函数函数名其实就是指向函数的变量高阶函数：能接收函数作为参数的函数 12345&gt;&gt;&gt;def add(x, y, f):... return f(x)+f(y)...&gt;&gt;&gt;add(-5, 9, abs)14 （这就是一个高阶函数的例子，变量f指向函数abs） map() 函数python内置的高阶函数，它接收一个函数 f 和一个 list，并通过把函数 f 依次作用在 list 的每个元素上，得到一个新的 list 并返回。注意：map()函数不改变原有的 list，而是返回一个新的 list。 reduce() 函数也是Python内置的一个高阶函数。reduce()函数接收的参数和 map()类似，一个函数 f，一个list，但行为和 map()不同，reduce()传入的函数 f 必须接收两个参数，reduce()对list的每个元素反复调用函数f，并返回最终结果值。 调用 reduce(f, [1, 3, 5, 7, 9])时，reduce函数将做如下计算：先计算头两个元素：f(1, 3)，结果为4；再把结果和第3个元素计算：f(4, 5)，结果为9；再把结果和第4个元素计算：f(9, 7)，结果为16；再把结果和第5个元素计算：f(16, 9)，结果为25；由于没有更多的元素了，计算结束，返回结果25。 reduce()还可以接收第3个可选参数，作为计算的初始值。如果把初始值设为100，计算： filter() 函数是 Python 内置的另一个有用的高阶函数，filter()函数接收一个函数 f 和一个list，这个函数 f 的作用是对每个元素进行判断，返回 True或 False，filter()根据判断结果自动过滤掉不符合条件的元素，返回由符合条件元素组成的新list。利用filter()，可以完成很多有用的功能，例如，删除 None 或者空字符串： 1234def is_not_empty(s): return s and len(s.strip()) &gt; 0filter(is_not_empty, ['test', None, '', 'str', ' ', 'END'])结果：['test', 'str', 'END'] 注意: s.strip(rm) 删除 s 字符串中开头、结尾处的 rm 序列的字符。当rm为空时，默认删除空白符（包括’\n’, ‘\r’, ‘\t’, ‘ ‘) 123a='\t\t123\r\n'a.strip()结果：'123' Python内置的 sorted() 函数可对list进行排序：但 sorted()也是一个高阶函数，它可以接收一个比较函数来实现自定义排序，比较函数的定义是，传入两个待比较的元素 x, y，如果 x 应该排在 y 的前面，返回 -1，如果 x 应该排在 y 的后面，返回 1。如果 x 和 y 相等，返回 0。因此，如果我们要实现倒序排序，只需要编写一个reversed_cmp函数：这样，调用 sorted() 并传入 reversed_cmp 就可以实现倒序排序：12345678def reversed_cmp(x, y): if x &gt; y: return -1 if x &lt; y: return 1 return 0 &gt;&gt;&gt;sorted([36, 5, 12, 9, 21], reversed_cmp)[36, 21, 12, 9, 5] python中返回函数Python的函数不但可以返回int、str、list、dict等数据类型，还可以返回函数！例如，定义一个函数 f()，我们让它返回一个函数 g，可以这样写：1234567def f(): print 'call f()...' # 定义函数g: def g(): print 'call g()...' # 返回函数g: return g 调用函数 f，我们会得到 f 返回的一个函数：123456&gt;&gt;&gt; x = f() # 调用f()call f()...&gt;&gt;&gt; x # 变量x是f()返回的函数：&lt;function g at 0x1037bf320&gt;&gt;&gt;&gt; x() # x指向函数，因此可以调用call g()... # 调用x()就是执行g()函数定义的代码 python中闭包在函数内部定义的函数和外部定义的函数是一样的，只是他们无法被外部访问：123456def g(): print 'g()...'def f(): print 'f()...' return g 将 g 的定义移入函数 f 内部，防止其他代码调用 g：12345def f(): print 'f()...' def g(): print 'g()...' return g 但是，考察上一小节定义的 calc_sum 函数：1234def calc_sum(lst): def lazy_sum(): return sum(lst) return lazy_sum 注意: 发现没法把 lazy_sum 移到 calc_sum 的外部，因为它引用了 calc_sum 的参数 lst。 像这种内层函数引用了外层函数的变量（参数也算变量），然后返回内层函数的情况，称为闭包（Closure）。 闭包的特点是返回的函数还引用了外层函数的局部变量，所以，要正确使用闭包，就要确保引用的局部变量在函数返回后不能变。举例如下：123456789#希望一次返回3个函数，分别计算1x1,2x2,3x3:def count(): fs = [] for i in range(1, 4): def f(): return i*i fs.append(f) return fsf1, f2, f3 = count() 你可能认为调用f1()，f2()和f3()结果应该是1，4，9，但实际结果全部都是 9。原因就是当count()函数返回了3个函数时，这3个函数所引用的变量 i 的值已经变成了3。由于f1、f2、f3并没有被调用，所以，此时他们并未计算 ii，当 f1 被调用时：即为3 3。 应修改为：12345678910111213def count(): fs = [] for i in range(1, 4): def f(j): #它可以正确地返回一个闭包g，g所引用的变量j不是循环变量，因此将正常执行。避免引用循环变量i def g(): return j*j return g r = f(i) fs.append(r) return fsf1, f2, f3 = count()print f1(), f2(), f3() python中匿名函数高阶函数可以接收函数做参数，有些时候，我们不需要显式地定义函数，直接传入匿名函数更方便。在Python中，对匿名函数提供了有限支持。还是以map()函数为例，计算 f(x)=x2 时，除了定义一个f(x)的函数外，还可以直接传入匿名函数：12&gt;&gt;&gt; map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9])[1, 4, 9, 16, 25, 36, 49, 64, 81] 通过对比可以看出，匿名函数 lambda x: x * x 实际上就是：12def f(x): return x * x 关键字lambda 表示匿名函数，冒号前面的 x 表示函数参数。匿名函数有个限制，就是只能有一个表达式，不写return，返回值就是该表达式的结果。使用匿名函数，可以不必定义函数名，直接创建一个函数对象，很多时候可以简化代码：123&gt;&gt;&gt; sorted([1, 3, 9, 5, 0], lambda x,y: -cmp(x,y))[9, 5, 3, 1, 0]` 12345def is_not_empty(s): return s and len(s.strip()) &gt; 0filter(is_not_empty, ['test', None, '', 'str', ' ', 'END'])print filter(lambda s: s and len(s.strip())&gt;0, ['test', None, '', 'str', ' ', 'END']) python中decorator装饰器-无参数装饰器讲解 Python的 decorator 本质上就是一个高阶函数，它接收一个函数作为参数，然后，返回一个新函数。使用 decorator 用Python提供的 @ 语法，这样可以避免手动编写 f = decorate(f) 这样的代码。123456考察一个@log的定义：可以用在任何参数只有一个的函数上，效果就是打印出“call 该函数名”def log(f): def fn(x): print 'call ' + f.__name__ + '()...' return f(x) return fn 但是，对于参数不是一个的函数，调用将报错：因为 add() 函数需要传入两个参数，但是 @log 写死了只含一个参数的返回函数。要让 @log 自适应任何参数定义的函数，可以利用Python的 *args 和 **kw，保证任意个数的参数总是能正常调用：12345def log(f): def fn(*args, **kw): print 'call ' + f.__name__ + '()...' return f(*args, **kw) return fn 现在，对于任意函数，@log 都能正常工作。 例题：请编写一个@performance，它可以打印出函数调用的时间。计算函数调用的时间可以记录调用前后的当前时间戳，然后计算两个时间戳的差。1234567891011121314import timedef performance(f): def fn(*args, **kw): t1 = time.time() r = f(*args, **kw) # f即为要被执行的函数， 也是要被装饰的函数 t2 = time.time() print 'call %s() in %fs' % (f.__name__, (t2 - t1)) return r return fn@performancedef factorial(n): return reduce(lambda x,y: x*y, range(1, n+1))print factorial(10) python中decorator装饰器-带参数考察上一节的 @log 装饰器：发现对于被装饰的函数，log打印的语句是不能变的（除了函数名）。如果有的函数非常重要，希望打印出’[INFO] call xxx()…’，有的函数不太重要，希望打印出’[DEBUG] call xxx()…’，这时，log函数本身就需要传入’INFO’或’DEBUG’这样的参数，类似这样：12345@log('DEBUG')def my_func(): pass#把上面的定义翻译成高阶函数的调用，就是：my_func = log('DEBUG')(my_func) 所以，带参数的log函数首先返回一个decorator函数，再让这个decorator函数接收my_func并返回新函数：123456789101112131415def log(prefix): def log_decorator(f): def wrapper(*args, **kw): print '[%s] %s()...' % (prefix, f.__name__) return f(*args, **kw) return wrapper return log_decorator@log('DEBUG')def test(): passprint test()#执行结果[DEBUG] test()...None 任务：上一节的@performance只能打印秒，请给 @performace 增加一个参数，允许传入’s’或’ms’：@performance(‘ms’)def factorial(n): return reduce(lambda x,y: x*y, range(1, n+1))12345678910111213141516171819import timedef performance(unit): def perf_decorator(f): def wrapper(*args, **kw): t1 = time.time() r = f(*args, **kw) t2 = time.time() t = (t2 - t1) * 1000 if unit=='ms' else (t2-t1) print 'call %s() in %f %s' % (f.__name__, t, unit) return r return wrapper return perf_decorator@performance('ms')def factorial(n): return reduce(lambda x,y: x*y, range(1, n+1))print factorial(10) python中完善decorator完善decorator@decorator可以动态实现函数功能的增加，但是，经过 @decorator “改造”后的函数，和原函数相比，除了功能多一点外，有没有其它不同的地方？可见，由于decorator返回的新函数函数名已经不是‘f2’，而是@log内部定义的‘wrapper’。这对于那些依赖函数名的代码就会失效。 decorator 还改变了函数的doc等其它属性。如果要让调用者看不出一个函数经过了@decorator的“改造”，就需要把原函数的一些属性复制到新函数中：1234567def log(f): def wrapper(*args, **kw): print 'call...' return f(*args, **kw) wrapper.__name__ = f.__name__ wrapper.__doc__ = f.__doc__ return wrapper 这样写decorator很不方便，因为我们也很难把原函数的所有必要属性都一个一个复制到新函数上，所以Python内置的functools可以用来自动化完成这个“复制”的任务：1234567import functoolsdef log(f): @functools.wraps(f) def wrapper(*args, **kw): print 'call...' return f(*args, **kw) return wrapper 注意@functools.wraps应该作用在返回的新函数上 python中偏函数当一个函数有很多参数时，调用者就需要提供多个参数。如果减少参数个数，就可以简化调用者的负担。int()函数还提供额外的base参数，默认值为10。如果传入base参数，就可以做 N 进制的转换：假设要转换大量的二进制字符串，每次都传入int(x, base=2)非常麻烦，于是，我们想到，可以定义一个 int2() 的函数，默认把 base=2 传进去：12def int2(x, base=2): return int(x, base) functools.partial就是帮助我们创建一个偏函数的，不需要我们自己定义int2()，可以直接使用下面的代码创建一个新的函数int2：1234&gt;&gt;&gt; import functools&gt;&gt;&gt; int2 = functools.partial(int, base=2)&gt;&gt;&gt; int2('1000000')64 所以，functools.partial可以把一个参数多的函数变成一个参数少的新函数，少的参数需要在创建时指定默认值，这样，新函数调用的难度就降低了。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python基础语法重点]]></title>
    <url>%2F2018%2F12%2F05%2Fpython%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E9%87%8D%E7%82%B9%2F</url>
    <content type="text"><![CDATA[用一周学习完Python的基础语法知识以后，再回头浏览一遍语法知识，将一些python独有的和容易被疏漏的初级知识总结在这里。 @TOC 目录Python中Unicode字符串如果一个字符串包含很多需要转义的字符，对每一个字符都进行转义会很麻烦。为了避免这种情况，我们可以在字符串前面加个前缀 r ，表示这是一个 raw 字符串，里面的字符就不需要转义了。例如： r&apos;\(~_~)/ \(~_~)/&apos; 如果字符串既包含’又包含”怎么办？ 这个时候，就需要对字符串的某些特殊字符进行“转义”，Python字符串用\进行转义。要表示字符串 Bob said “I’m OK”.由于 ‘ 和 “ 会引起歧义，因此，我们在它前面插入一个\表示这是一个普通字符，不代表字符串的起始，因此，这个字符串又可以表示为 &apos;Bob said \&quot;I\&apos;m OK\&quot;.&apos; Python中Unicode字符串Python在后来添加了对Unicode的支持，以Unicode表示的字符串用u’…’表示，比如： print u&apos;中文&apos; 中文 如果中文字符串在Python环境下遇到 UnicodeDecodeError，这是因为 .py文件保存的格式有问题。可以在第一行添加注释 # -*- coding: utf-8 -*- 目的是告诉Python解释器，用UTF-8编码读取源代码。然后用Notepad++ 另存为… 并选择UTF-8格式保存。 Python中布尔类型在Python中，布尔类型还可以与其他数据类型做 and、or和not运算，请看下面的代码： a = True print a and &apos;a=T&apos; or &apos;a=F&apos; 计算结果不是布尔类型，而是字符串 ‘a=T’，这是为什么呢？因为Python把0、空字符串’’和None看成 False，其他数值和非空字符串都看成 True，所以：True and ‘a=T’ 计算结果是 ‘a=T’继续计算 ‘a=T’ or ‘a=F’ 计算结果还是 ‘a=T’ Python之创建tuple因为()既可以表示tuple，又可以作为括号表示运算时的优先级，结果 (1) 被Python解释器计算出结果 1，导致我们得到的不是tuple，而是整数 1。正是因为用()定义单元素的tuple有歧义，所以 Python 规定，单元素 tuple 要多加一个逗号“,”，这样就避免了歧义： &gt;&gt;&gt; t = (1,) &gt;&gt;&gt; print t (1,) Python在打印单元素tuple时，也自动添加了一个“,”，为了更明确地告诉你这是一个tuple。 Python之“可变”的tupletuple一开始指向的list并没有改成别的list，所以，tuple所谓的“不变”是说，tuple的每个元素，指向永远不变。即指向’a’，就不能改成指向’b’，指向一个list，就不能改成指向其他对象，但指向的这个list本身是可变的！理解了“指向不变”后，要创建一个内容也不变的tuple怎么做？那就必须保证tuple的每一个元素本身也不能变。 Python之 if-elif-else要避免嵌套结构的 if … else …，我们可以用 ==if … 多个elif … else …== 的结构，一次写完所有的规则： if age &gt;= 18: print &apos;adult&apos; elif age &gt;= 6: print &apos;teenager&apos; elif age &gt;= 3: print &apos;kid&apos; else: print &apos;baby&apos; ==elif== 意思就是 ==else if==。这样一来，我们就写出了结构非常清晰的一系列条件判断。 Python之什么是dictdict的第一个特点是==查找速度快==，无论dict有10个元素还是10万个元素，查找速度都一样。 而list的查找速度随着元素增加而逐渐下降。dict的第二个特点就是存储的key-value序对是==没有顺序==的！ 这和list不一样： 打印的顺序不一定是我们创建时的顺序，而且，不同的机器打印的顺序都可能不同，这说明dict内部是无序的，不能用dict存储有序的集合。dict的第三个特点是作为 key 的元素必须==不可变==，Python的基本类型如字符串str、整数int、浮点数float 都是不可变的，都可以作为 key。但是list是可变的，就不能作为 key。 不可变这个限制仅作用于key，value是否可变无所谓： { &apos;123&apos;: [1, 2, 3], # key 是 str，value是list 123: &apos;123&apos;, # key 是 int，value 是 str (&apos;a&apos;, &apos;b&apos;): True # key 是 tuple，并且tuple的每个元素都是不可变对象，value是 boolean } 最常用的key还是字符串，因为用起来最方便。 Python中 什么是setdict的作用是建立一组 key 和一组 value 的映射关系，dict的key是不能重复的。有的时候，我们只想要 dict 的 key，不关心 key 对应的 value，目的就是保证这个集合的元素不会重复，这时，set就派上用场了。set 持有一系列元素，这一点和 list 很像，但是set的元素没有重复，而且是无序的，这点和 dict 的 key很像。创建 set 的方式是调用 set() 并传入一个 list，list的元素将作为set的元素： &gt;&gt;&gt; s = set([&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]) 由于set存储的是无序集合，所以我们没法通过索引来访问。访问 set中的某个元素实际上就是判断一个元素是否在set中。例如，存储了班里同学名字的set： &gt;&gt;&gt; s = set([&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Paul&apos;]) 我们可以用 in 操作符判断：Bart是该班的同学吗？ &gt;&gt;&gt; &apos;Bart&apos; in s True 看来大小写很重要，’Bart’ 和 ‘bart’被认为是两个不同的元素。 set的内部结构和dict很像，唯一区别是不存储value，因此，判断一个元素是否在set中速度很快。set存储的元素和dict的key类似，必须是不变对象，因此，任何可变对象是不能放入set中的。最后，==set存储的元素也是没有顺序的==。 Python函数之返回多值这样我们就可以同时获得返回值： &gt;&gt;&gt; x, y = move(100, 100, 60, math.pi / 6) &gt;&gt;&gt; print x, y 151.961524227 70.0 但其实这只是一种假象，Python函数返回的仍然是单一值： &gt;&gt;&gt; r = move(100, 100, 60, math.pi / 6) &gt;&gt;&gt; print r (151.96152422706632, 70.0) 用print打印返回结果，原来返回值是一个tuple！但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。 ==使用递归函数需要注意防止栈溢出==。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。可以试试计算 fact(10000)。 Python之定义默认参数定义函数的时候，还可以有默认参数。例如Python自带的 int() 函数，其实就有两个参数，我们既可以传一个参数，又可以传两个参数： &gt;&gt;&gt; int(&apos;123&apos;) 123 &gt;&gt;&gt; int(&apos;123&apos;, 8) 83 int()函数的第二个参数是转换进制，如果不传，默认是十进制 (base=10)，如果传了，就用传入的参数。可见，函数的默认参数的作用是简化调用，你只需要把必须的参数传进去。但是在需要的时候，又可以传入额外的参数来覆盖默认参数值。 Python之定义可变参数如果想让一个函数能接受任意个参数，我们就可以定义一个可变参数： def fn(*args): print args 可变参数的名字前面有个*号，我们可以传入0个、1个或多个参数给可变参数：可变参数也不是很神秘，Python解释器会把传入的一组参数组装成一个tuple传递给可变参数，因此，在函数内部，直接把变量 args看成一个 tuple 就好了。 tuple: 创建tuple和创建list唯一不同之处是用( )替代了[ ]。现在，这个 t 就不能改变了，tuple没有 append()方法，也没有insert()和pop()方法。所以，新同学没法直接往 tuple 中添加，老同学想退出 tuple 也不行。 对list进行切片对这种经常取指定索引范围的操作，用循环十分繁琐，因此，Python提供了切片（Slice）操作符，能大大简化这种操作。对应上面的问题，取前3个元素，用一行代码就可以完成切片： `&gt;&gt;&gt; L[0:3] [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;]` L[0:3]表示，从索引0开始取，直到索引3为止，但不包括索引3。即索引0，1，2，正好是3个元素。如果第一个索引是0，还可以省略： &gt;&gt;&gt; L[:3] [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;] 也可以从索引1开始，取出2个元素出来： &gt;&gt;&gt; L[1:3] [&apos;Lisa&apos;, &apos;Bart&apos;] 只用一个 : ，表示从头到尾： &gt;&gt;&gt; L[:] &apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Paul&apos;] 因此，L[:]实际上复制出了一个新list。切片操作还可以指定第三个参数： &gt;&gt;&gt; L[::2] [&apos;Adam&apos;, &apos;Bart&apos;] 第三个参数表示每N个取一个，上面的 L[::2] 会每两个元素取出一个来，也就是隔一个取一个。把list换成tuple，切片操作完全相同，只是切片的结果也变成了tuple。 索引迭代Python中，迭代永远是取出元素本身，而非元素的索引。对于有序集合，元素确实是有索引的。有的时候，我们确实想在 for 循环中拿到索引，怎么办？ 方法是使用 ==enumerate() 函数==： &gt;&gt;&gt; L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Paul&apos;] &gt;&gt;&gt; for index, name in enumerate(L): ... print index, &apos;-&apos;, name ... 0 - Adam 1 - Lisa 2 - Bart 3 - Paul 使用 enumerate() 函数，我们可以在for循环中同时绑定索引index和元素name。但是，这不是 enumerate() 的特殊语法。实际上，enumerate() 函数把： [‘Adam’, ‘Lisa’, ‘Bart’, ‘Paul’]变成了类似： [(0, ‘Adam’), (1, ‘Lisa’), (2, ‘Bart’), (3, ‘Paul’)]因此，迭代的每一个元素实际上是一个tuple： for t in enumerate(L): index = t[0] name = t[1] print index, &apos;-&apos;, name 如果我们知道每个tuple元素都包含两个元素，for循环又可以进一步简写为： for index, name in enumerate(L): print index, &apos;-&apos;, name 这样不但代码更简单，而且还少了两条赋值语句。 可见，索引迭代也不是真的按索引访问，而是由 enumerate() 函数自动把每个元素变成 (index, element) 这样的tuple，再迭代，就同时获得了索引和元素本身。 zip()函数可以把两个 list 变成一个 list： &gt;&gt;&gt; zip([10, 20, 30], [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]) [(10, &apos;A&apos;), (20, &apos;B&apos;), (30, &apos;C&apos;)] 在迭代 [‘Adam’, ‘Lisa’, ‘Bart’, ‘Paul’] 时，如果我们想打印出名次 - 名字（名次从1开始)，请考虑如何在迭代中打印出来。 L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Paul&apos;] for index, name in zip(range(1, len(L)+1), L): print index, &apos;-&apos;, name 迭代dict的value如果我们希望迭代 dict 对象的value，应该怎么做？dict 对象有一个 values() 方法，这个方法把dict转换成一个包含所有value的list，这样，我们迭代的就是 dict的每一个 value：如果仔细阅读Python的文档，还可以发现，dict除了 values() 方法外，还有一个 itervalues() 方法，用 itervalues() 方法替代 values() 方法，迭代效果完全一样：那这两个方法有何不同之处呢？ values() 方法实际上把一个 dict 转换成了包含 value 的list。 但是 itervalues() 方法不会转换，它会在迭代过程中依次从 dict 中取出 value，所以 itervalues() 方法比 values() 方法节省了生成 list 所需的内存。 打印 itervalues() 发现它返回一个 对象，这说明在Python中，for 循环可作用的迭代对象远不止 list，tuple，str，unicode，dict等，任何可迭代对象都可以作用于for循环，而内部如何迭代我们通常并不用关心。如果一个对象说自己可迭代，那我们就直接用 for 循环去迭代它，可见，迭代是一种抽象的数据操作，它不对迭代对象内部的数据有任何要求。 迭代dict的key和value我们了解了如何迭代 dict 的key和value，那么，在一个 for 循环中，能否同时迭代 key和value？答案是肯定的。首先，我们看看 dict 对象的 items() 方法返回的值： &gt;&gt;&gt; d = { &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59 } &gt;&gt;&gt; print d.items() [(&apos;Lisa&apos;, 85), (&apos;Adam&apos;, 95), (&apos;Bart&apos;, 59)] 可以看到，items() 方法把dict对象转换成了包含tuple的list，我们对这个list进行迭代，可以同时获得key和value：和 values() 有一个 itervalues() 类似， items() 也有一个对应的 iteritems()，iteritems() 不把dict转换成list，而是在迭代过程中不断给出 tuple，所以， iteritems() 不占用额外的内存。 列表生成式如果要生成[1x1, 2x2, 3x3, …, 10x10]怎么做？方法一是循环： &gt;&gt;&gt; L = [] &gt;&gt;&gt; for x in range(1, 11): ... L.append(x * x) 但是循环太繁琐，而列表生成式则可以用一行语句代替循环生成上面的list： &gt;&gt;&gt; [x * x for x in range(1, 11)] [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 这种写法就是Python特有的列表生成式。利用列表生成式，可以以非常简洁的代码生成 list。写列表生成式时，把要生成的元素 x * x 放到前面，后面跟 for 循环，就可以把list创建出来，十分有用，多写几次，很快就可以熟悉这种语法。 复杂表达式完全可以通过一个复杂的列表生成式把它变成一个 HTML 表格： tds = [&apos;&lt;tr&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;/tr&gt;&apos; % (name, score) for name, score in d.iteritems()] 注：字符串可以通过%进行格式化，用指定的参数替代 %s。字符串的join()方法可以把一个 list 拼接成一个字符串。 条件过滤列表生成式的 for 循环后面还可以加上 if 判断。例如： &gt;&gt;&gt; [x * x for x in range(1, 11)] [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>编程</tag>
      </tags>
  </entry>
</search>

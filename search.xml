<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python基本语法整理]]></title>
    <url>%2F2018%2F11%2F22%2Fsearch%2F</url>
    <content type="text"><![CDATA[用一周学习完Python的基础语法知识以后，再回头浏览一遍语法知识，将一些python独有的和容易被疏漏的初级知识总结在这里。同时，下一篇就是进阶的Python语法知识点啦~ @TOC 目录Python中Unicode字符串如果一个字符串包含很多需要转义的字符，对每一个字符都进行转义会很麻烦。为了避免这种情况，我们可以在字符串前面加个前缀 r ，表示这是一个 raw 字符串，里面的字符就不需要转义了。例如： r&apos;\(~_~)/ \(~_~)/&apos; 如果字符串既包含’又包含”怎么办？这个时候，就需要对字符串的某些特殊字符进行“转义”，Python字符串用\进行转义。要表示字符串 Bob said “I’m OK”.由于 ‘ 和 “ 会引起歧义，因此，我们在它前面插入一个\表示这是一个普通字符，不代表字符串的起始，因此，这个字符串又可以表示为 &apos;Bob said \&quot;I\&apos;m OK\&quot;.&apos; Python中Unicode字符串Python在后来添加了对Unicode的支持，以Unicode表示的字符串用u’…’表示，比如： print u&apos;中文&apos; 中文 如果中文字符串在Python环境下遇到 UnicodeDecodeError，这是因为 .py文件保存的格式有问题。可以在第一行添加注释 # -*- coding: utf-8 -*- 目的是告诉Python解释器，用UTF-8编码读取源代码。然后用Notepad++ 另存为… 并选择UTF-8格式保存。 Python中布尔类型在Python中，布尔类型还可以与其他数据类型做 and、or和not运算，请看下面的代码： a = True print a and &apos;a=T&apos; or &apos;a=F&apos; 计算结果不是布尔类型，而是字符串 ‘a=T’，这是为什么呢？因为Python把0、空字符串’’和None看成 ==False==，==其他数值==和==非空字符串==都看成 True，所以：True and ‘a=T’ 计算结果是 ‘a=T’继续计算 ‘a=T’ or ‘a=F’ 计算结果还是 ‘a=T’ Python之创建tuple因为()既可以表示tuple，又可以作为括号表示运算时的优先级，结果 (1) 被Python解释器计算出结果 1，导致我们得到的不是tuple，而是整数 1。正是因为用()定义单元素的tuple有歧义，所以 Python 规定，单元素 tuple 要多加一个逗号“,”，这样就避免了歧义： &gt;&gt;&gt; t = (1,) &gt;&gt;&gt; print t (1,) Python在打印单元素tuple时，也自动添加了一个“,”，为了更明确地告诉你这是一个tuple。 Python之“可变”的tupletuple一开始指向的list并没有改成别的list，所以，tuple所谓的“不变”是说，tuple的每个元素，指向永远不变。即指向’a’，就不能改成指向’b’，指向一个list，就不能改成指向其他对象，但指向的这个list本身是可变的！理解了“指向不变”后，要创建一个内容也不变的tuple怎么做？那就必须保证tuple的每一个元素本身也不能变。 Python之 if-elif-else要避免嵌套结构的 if … else …，我们可以用 ==if … 多个elif … else …== 的结构，一次写完所有的规则： if age &gt;= 18: print &apos;adult&apos; elif age &gt;= 6: print &apos;teenager&apos; elif age &gt;= 3: print &apos;kid&apos; else: print &apos;baby&apos; ==elif== 意思就是 ==else if==。这样一来，我们就写出了结构非常清晰的一系列条件判断。 Python之什么是dictdict的第一个特点是==查找速度快==，无论dict有10个元素还是10万个元素，查找速度都一样。 而list的查找速度随着元素增加而逐渐下降。dict的第二个特点就是存储的key-value序对是==没有顺序==的！ 这和list不一样： 打印的顺序不一定是我们创建时的顺序，而且，不同的机器打印的顺序都可能不同，这说明dict内部是无序的，不能用dict存储有序的集合。dict的第三个特点是作为 key 的元素必须==不可变==，Python的基本类型如字符串str、整数int、浮点数float 都是不可变的，都可以作为 key。但是list是可变的，就不能作为 key。 不可变这个限制仅作用于key，value是否可变无所谓： { &apos;123&apos;: [1, 2, 3], # key 是 str，value是list 123: &apos;123&apos;, # key 是 int，value 是 str (&apos;a&apos;, &apos;b&apos;): True # key 是 tuple，并且tuple的每个元素都是不可变对象，value是 boolean } 最常用的key还是字符串，因为用起来最方便。 Python中 什么是setdict的作用是建立一组 key 和一组 value 的映射关系，dict的key是不能重复的。有的时候，我们只想要 dict 的 key，不关心 key 对应的 value，目的就是保证这个集合的元素不会重复，这时，set就派上用场了。set 持有一系列元素，这一点和 list 很像，但是set的元素没有重复，而且是无序的，这点和 dict 的 key很像。创建 set 的方式是调用 set() 并传入一个 list，list的元素将作为set的元素： &gt;&gt;&gt; s = set([&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]) 由于set存储的是无序集合，所以我们没法通过索引来访问。访问 set中的某个元素实际上就是判断一个元素是否在set中。例如，存储了班里同学名字的set： &gt;&gt;&gt; s = set([&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Paul&apos;]) 我们可以用 in 操作符判断：Bart是该班的同学吗？ &gt;&gt;&gt; &apos;Bart&apos; in s True 看来大小写很重要，’Bart’ 和 ‘bart’被认为是两个不同的元素。 set的内部结构和dict很像，唯一区别是不存储value，因此，判断一个元素是否在set中速度很快。set存储的元素和dict的key类似，必须是不变对象，因此，任何可变对象是不能放入set中的。最后，==set存储的元素也是没有顺序的==。 Python函数之返回多值这样我们就可以同时获得返回值： &gt;&gt;&gt; x, y = move(100, 100, 60, math.pi / 6) &gt;&gt;&gt; print x, y 151.961524227 70.0 但其实这只是一种假象，Python函数返回的仍然是单一值： &gt;&gt;&gt; r = move(100, 100, 60, math.pi / 6) &gt;&gt;&gt; print r (151.96152422706632, 70.0) 用print打印返回结果，原来返回值是一个tuple！但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。 ==使用递归函数需要注意防止栈溢出==。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。可以试试计算 fact(10000)。 Python之定义默认参数定义函数的时候，还可以有默认参数。例如Python自带的 int() 函数，其实就有两个参数，我们既可以传一个参数，又可以传两个参数： &gt;&gt;&gt; int(&apos;123&apos;) 123 &gt;&gt;&gt; int(&apos;123&apos;, 8) 83 int()函数的第二个参数是转换进制，如果不传，默认是十进制 (base=10)，如果传了，就用传入的参数。可见，函数的默认参数的作用是简化调用，你只需要把必须的参数传进去。但是在需要的时候，又可以传入额外的参数来覆盖默认参数值。 Python之定义可变参数如果想让一个函数能接受任意个参数，我们就可以定义一个可变参数： def fn(*args): print args 可变参数的名字前面有个*号，我们可以传入0个、1个或多个参数给可变参数：可变参数也不是很神秘，Python解释器会把传入的一组参数组装成一个tuple传递给可变参数，因此，在函数内部，直接把变量 ==args==看成一个 ==tuple== 就好了。 tuple: 创建tuple和创建list唯一不同之处是用( )替代了[ ]。现在，这个 t 就不能改变了，tuple没有 append()方法，也没有insert()和pop()方法。所以，新同学没法直接往 tuple 中添加，老同学想退出 tuple 也不行。 对list进行切片对这种经常取指定索引范围的操作，用循环十分繁琐，因此，Python提供了切片（Slice）操作符，能大大简化这种操作。对应上面的问题，取前3个元素，用一行代码就可以完成切片： `&gt;&gt;&gt; L[0:3] [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;]` L[0:3]表示，从索引0开始取，直到索引3为止，但不包括索引3。即索引0，1，2，正好是3个元素。如果第一个索引是0，还可以省略： &gt;&gt;&gt; L[:3] [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;] 也可以从索引1开始，取出2个元素出来： &gt;&gt;&gt; L[1:3] [&apos;Lisa&apos;, &apos;Bart&apos;] 只用一个 : ，表示从头到尾： &gt;&gt;&gt; L[:] &apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Paul&apos;] 因此，L[:]实际上复制出了一个新list。切片操作还可以指定第三个参数： &gt;&gt;&gt; L[::2] [&apos;Adam&apos;, &apos;Bart&apos;] 第三个参数表示每N个取一个，上面的 L[::2] 会每两个元素取出一个来，也就是隔一个取一个。把list换成tuple，切片操作完全相同，只是切片的结果也变成了tuple。 索引迭代Python中，迭代永远是取出元素本身，而非元素的索引。对于有序集合，元素确实是有索引的。有的时候，我们确实想在 for 循环中拿到索引，怎么办？ 方法是使用 ==enumerate() 函数==： &gt;&gt;&gt; L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Paul&apos;] &gt;&gt;&gt; for index, name in enumerate(L): ... print index, &apos;-&apos;, name ... 0 - Adam 1 - Lisa 2 - Bart 3 - Paul 使用 enumerate() 函数，我们可以在for循环中同时绑定索引index和元素name。但是，这不是 enumerate() 的特殊语法。实际上，enumerate() 函数把： [‘Adam’, ‘Lisa’, ‘Bart’, ‘Paul’]变成了类似： [(0, ‘Adam’), (1, ‘Lisa’), (2, ‘Bart’), (3, ‘Paul’)]因此，迭代的每一个元素实际上是一个tuple： for t in enumerate(L): index = t[0] name = t[1] print index, &apos;-&apos;, name 如果我们知道每个tuple元素都包含两个元素，for循环又可以进一步简写为： for index, name in enumerate(L): print index, &apos;-&apos;, name 这样不但代码更简单，而且还少了两条赋值语句。 可见，索引迭代也不是真的按索引访问，而是由 enumerate() 函数自动把每个元素变成 (index, element) 这样的tuple，再迭代，就同时获得了索引和元素本身。 zip()函数可以把两个 list 变成一个 list： &gt;&gt;&gt; zip([10, 20, 30], [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]) [(10, &apos;A&apos;), (20, &apos;B&apos;), (30, &apos;C&apos;)] 在迭代 [‘Adam’, ‘Lisa’, ‘Bart’, ‘Paul’] 时，如果我们想打印出名次 - 名字（名次从1开始)，请考虑如何在迭代中打印出来。 L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Paul&apos;] for index, name in zip(range(1, len(L)+1), L): print index, &apos;-&apos;, name 迭代dict的value如果我们希望迭代 dict 对象的value，应该怎么做？dict 对象有一个 values() 方法，这个方法把dict转换成一个包含所有value的list，这样，我们迭代的就是 dict的每一个 value：如果仔细阅读Python的文档，还可以发现，dict除了 values() 方法外，还有一个 itervalues() 方法，用 itervalues() 方法替代 values() 方法，迭代效果完全一样：那这两个方法有何不同之处呢？ values() 方法实际上把一个 dict 转换成了包含 value 的list。 但是 itervalues() 方法不会转换，它会在迭代过程中依次从 dict 中取出 value，所以 itervalues() 方法比 values() 方法节省了生成 list 所需的内存。 打印 itervalues() 发现它返回一个 对象，这说明在Python中，for 循环可作用的迭代对象远不止 list，tuple，str，unicode，dict等，任何可迭代对象都可以作用于for循环，而内部如何迭代我们通常并不用关心。如果一个对象说自己可迭代，那我们就直接用 for 循环去迭代它，可见，迭代是一种抽象的数据操作，它不对迭代对象内部的数据有任何要求。 迭代dict的key和value我们了解了如何迭代 dict 的key和value，那么，在一个 for 循环中，能否同时迭代 key和value？答案是肯定的。首先，我们看看 dict 对象的 items() 方法返回的值： &gt;&gt;&gt; d = { &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59 } &gt;&gt;&gt; print d.items() [(&apos;Lisa&apos;, 85), (&apos;Adam&apos;, 95), (&apos;Bart&apos;, 59)] 可以看到，items() 方法把dict对象转换成了包含tuple的list，我们对这个list进行迭代，可以同时获得key和value：和 values() 有一个 itervalues() 类似， items() 也有一个对应的 iteritems()，iteritems() 不把dict转换成list，而是在迭代过程中不断给出 tuple，所以， iteritems() 不占用额外的内存。 列表生成式如果要生成[1x1, 2x2, 3x3, …, 10x10]怎么做？方法一是循环： &gt;&gt;&gt; L = [] &gt;&gt;&gt; for x in range(1, 11): ... L.append(x * x) 但是循环太繁琐，而列表生成式则可以用一行语句代替循环生成上面的list： &gt;&gt;&gt; [x * x for x in range(1, 11)] [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 这种写法就是Python特有的列表生成式。利用列表生成式，可以以非常简洁的代码生成 list。写列表生成式时，把要生成的元素 x * x 放到前面，后面跟 for 循环，就可以把list创建出来，十分有用，多写几次，很快就可以熟悉这种语法。 复杂表达式完全可以通过一个复杂的列表生成式把它变成一个 HTML 表格： tds = [&apos;&lt;tr&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;/tr&gt;&apos; % (name, score) for name, score in d.iteritems()] 注：字符串可以通过%进行格式化，用指定的参数替代 %s。字符串的join()方法可以把一个 list 拼接成一个字符串。 条件过滤列表生成式的 for 循环后面还可以加上 if 判断。例如： &gt;&gt;&gt; [x * x for x in range(1, 11)] [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
</search>

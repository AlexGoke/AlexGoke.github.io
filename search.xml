<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Pipenv对比virtualenv]]></title>
    <url>%2F2019%2F07%2F31%2FPipenv%E5%AF%B9%E6%AF%94virtualenv%2F</url>
    <content type="text"><![CDATA[# 什么是PipenvPipenv是Kenneth Reitz在2017年1月发布的Python依赖管理工具，现在由PyPA维护。你可以把它看做是pip和virtualenv的组合体，而它基于的Pipfile则用来替代旧的依赖记录方式（requirements.txt）。 为什么使用PipenvPipenv会自动帮你管理虚拟环境和依赖文件，并且提供了一系列命令和选项来帮助你实现各种依赖和环境管理相关的操作。简而言之，它更方便、完善和安全。你可以通过Pipenv文档开头的介绍来了解它的详细特性。Pipenv的slogan是“Python Dev Workflow for Humans”，作为人类，当然应该尝试一下…… 如何使用Pipenv假设我们要编写一个博客程序，项目的依赖是Flask和Flask-WTF。顺便说一句，可以使用下面的命令安装Pipenv：1$ pip install pipenv 下面我会通过不同操作来给出所需命令的对比，OLD（旧）表示使用pip和virtualenv，NEW（新）表示使用Pipenv。 创建虚拟环境OLD： $ virtualenv venv 提示:这里的venv是虚拟环境目录的名称，你可以自由更改，这会在你的项目根目录创建一个venv文件夹，其中包含独立的Python解释器环境。 NEW： $ pipenv installPipenv会自动为你创建虚拟环境，自动生成一个随机的虚拟环境目录名。 激活虚拟环境OLD：在Linux或macOS系统中：$ . venv/bin/activate Windows：&gt; venv\Scripts\activate NEW： $ pipenv shell此外，Pipenv还提供了一个pipenv run命令，在该命令后附加的参数会直接作为命令在虚拟环境中执行，这允许你不必显式的激活虚拟环境即可在虚拟环境中执行命令。比如，pipenv run python会启动虚拟环境中的Python解释器。 安装依赖到虚拟环境OLD:12$ . venv/bin/activate # 需要先激活虚拟环境(venv)$ pip install flask flask-wtf NEW:使用Pipenv，不管你是否激活了虚拟环境，都可以通过pipenv install命令安装：1$ pipenv install flask flask-wtf 事实上，对一个新项目来说，你不必手动使用pipenv install来创建虚拟环境。当使用pipenv install xxx直接安装依赖包时，如果当前目录不包含虚拟环境，Pipenv会自动创建一个。 记录依赖OLD: (venv)$ pip freeze &gt; requirements.txt 这个命令会把依赖列表写入requirements.txt文件。每当你安装或卸载了依赖包时，都需要手动更新这个文件。你必须保持谨慎，否则非常容易把依赖列表弄乱。 NEW:使用Pipenv时，什么都不必做，Pipenv会自动帮你管理依赖。Pipenv会在你创建虚拟环境时自动创建Pipfile和Pipfile.lock文件（如果不存在），并且会在你使用pipenv install和pipenv uninstall命令安装和卸载包时自动更新Pipfile和Pipfile.lock。 附注 Pipfile用来记录项目依赖包列表，而Pipfile.lock记录了固定版本的详细依赖包列表。 在部署环境安装依赖OLD:当我们需要在一个新的环境，比如部署上线环境安装所有依赖时，我们需要重复上面的多条命令：123$ virtualenv venv # 创建虚拟环境$ . venv/bin/activate # 激活虚拟环境(venv)$ pip install -r requirements.txt # 安装requirement.txt中记录的依赖 NEW: 使用Pipenv则只需要执行pipenv install，它会自动安装Pipfile中记录的依赖：1$ pipenv install 区分开发依赖OLD: 使用requirements.txt时，我们通过会单独创建一个requirements-dev.txt文件来手动加入开发依赖。比如项目开发时才会用到pytest，那么你需要手动创建这个文件，然后写入：12 -r requirements.txtpytest==1.2.3 在新的开发环境安装依赖时，你需要安装这个文件中的依赖：1(venv)$ pip install -r requirements-dev.txt NEW: 使用Pipenv时，你只需要在安装pytest时添加一个–dev选项，它会自动被分类为开发依赖（写入Pipfile的dev-packages一节中）：$ pipenv install pytest --dev 在新的开发环境安装依赖时，也只需要在pipenv install命令后添加–dev选项即可一并安装开发依赖： $ pipenv install --dev 总结为了让你更轻松的过渡，Pipenv甚至提供了读取和生成requirements.txt文件的功能（在使用pipenv install命令时它会自动读取requirements.txt文件安装依赖并生成Pipfile文件）。 常见问题Q：自定义虚拟环境文件夹路径 A：默认情况下，Pipenv会自动为你选择虚拟环境的存储位置，在Windows下通常为C:\Users\Administrator.virtualenvs\，而Linux或macOS则为~/.local/share/virtualenvs/。如果你想将虚拟环境文件夹在项目目录内创建，可以设置环境变量PIPENV_VENV_IN_PROJECT，这时名为.venv的虚拟环境文件夹将在项目根目录被创建。另外你也可以通过WORKON_HOME环境变量来自定义存储路径。]]></content>
      <categories>
        <category>编程</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[委托-C#]]></title>
    <url>%2F2019%2F07%2F28%2F%E5%A7%94%E6%89%98-C%2F</url>
    <content type="text"><![CDATA[委托 委托是一个对象，它知道如何调用一个方法。 委托类型 &amp; 委托实例委托类型定义了委托实例可以调用的那类方法，具体来说，委托类型定义了方法的返回类型和参数。 12345//Transformer这个委托，所需参数和返回类型均为 int， 与下面的方法 Square() 一致，所以该委托可调用这个方法。delegate int Transformer(int x);static int Square(int x) &#123; return x*x &#125;static int Square(int x) =&gt; x*x; //Expression Body 形式 委托实例 委托的实例 其实就是调用者的委托：调用者调用委托，然后委托调用目标方法。 间接的把调用者和目标方法解耦了。 Demo1: 把方法赋值给委托变量的时候就创建了委托实例。 12Transformer t = Square; //简写形式Transformer t = new Transformer(Square); //完整形式 调用 12int answer = t(3); //简写形式，answer is 9t.invoke(3); //完整形式 编写插件式的方法 方法是在运行时才赋值给委托变量 Demo2： 多播委托所有的委托实例都具有多播的能力。一个委托实例可以引用一组目标方法。 “+” 和 “ += ” 操作符可以合并委托实例1234 SomeDelegate d = SomeMethod 1; d += SomeMethod2; d = d + SomeMethod2; 调用d就会调用SomeMethod1 和 SomeMethod2 委托的调用顺序与它们的定义顺序一致 “ - ” 和 “ -= ” 会把右边的委托从左边的委托里 移除 1d -= SomeMethod1; 委托变量使用 + 或 += 时，其操作数可以是 null。 使用 += 或 -= 时，实际上是创建了新的委托实例，并把它赋给当前的委托变量。 如果多播委托的返回类型不是 void，那么调用者从最后一个被调用的方法来接受返回值。前面的方法仍会被调用，但是其返回值被弃用了。 实例方法目标 和 静态方法目标 当一个实例方法被赋值给委托对象的时候，这个委托对象不仅要保留着对方法的引用，还要保留着方法所属实例的引用。 System.Delegate 的 Target属性 就代表着这个实例。如果引用的是静态方法，那么Target属性的值就是 null。 Demo3： 泛型委托类型 泛型委托类型可以包含泛型类型参数1public delegate T Transformer&lt;T&gt; (T arg); Demo: Func 和 Action 委托 （略过）使用泛型委托，就可以写出这样一组委托类型，它们可调用的方法可以拥有任意的返回类型和任意（合理）数量的参数 可以把上面Demo中的 Transform方法中的委托参数改为：结果也是一样的。1public static void Transform&lt;T&gt;(T[] values, Func&lt;T, T&gt; t) 委托 VS 接口委托可以解决的问题，接口都可以解决。 什么情况下更适合使用委托而不是接口呢？当下列条件满足之一： 接口只能定义一个方法 需要多播能力 订阅者需要多次实现接口 委托的兼容性 - 委托类型 委托类型之间互不相容，即使 签名方法一样： 12345delegate void D1();delegate void D2();...D1 d1 = Method1;D2 d2 = d1; //Compile - time error 如果委托实例拥有相同的方法目标，那么委托实例就认为是相等的。 12345 delegate void D();...D d1 = Method1;D d2 = Method1;console.WriteLine( d1 == d2); //True 委托的兼容性 - 参数 当调用一个方法时，提供的参数（argument）可以比方法的参数（parameter) 定义更具体。 委托可以接受比它的方法目标更具体的参数类型，这叫 ContraVariance. 逆变 委托的兼容性 - 返回类型 调用方法时，可以得到一个比请求的类型更具体的类型的返回结果 委托的目标方法可以返回bi委托描述里更具体的类型返回结果。Co’v’ariance 协变]]></content>
      <categories>
        <category>编程</category>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经典排序算法Python实现]]></title>
    <url>%2F2019%2F07%2F27%2F%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95Python%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[&gt; 经典排序算法在面试中占有很大的比重，也是基础。本篇博客所有排序实现均默认从小到大。 1.冒泡排序 BubbleSort冒泡排序的原理非常简单，它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。 步骤： 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对第0个到第n-1个数据做同样的工作。这时，最大的数就“浮”到了数组最后的位置上。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 实现：12345678def bubble_sort(array): for i in range(len(array)): #共需要遍历len(array)-1次 for j in range(len(array)-1): if array[j] &gt; array[j+1]: array[j],array[j+1] = array[j+1],array[j] array = [5,2,7,1,8,3,4,6,9,0]bubble_sort(array) 2.选择排序 SelectionSort步骤： 在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。 以此类推，直到所有元素均排序完毕。 实现：1234567891011def select_sort(array): for i in range(0, len(array)): min = i #记录最小值的下标 for j in range(i+1, len(array)): if array[j] &lt; array[min]: min = j array[i], array[min] = array[min], array[i] print(array) array = [5,2,7,1,8,3,4,6,9,0]select_sort(array) 3.插入排序 InsertionSort插入排序的工作原理是，对于每个未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 步骤： 从第一个元素开始，该元素可以认为已经被排序 取出下一个元素，在已经排序的元素序列中从后向前扫描 如果被扫描的元素（已排序）大于新元素，将该元素后移一位 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置 将新元素插入到该位置后 重复步骤2~5 实现：123456789101112131415 def insert_sort(array): for i in range(1, len(array)): current = array[i] index = i while index &gt;= 1: if array[index-1] &gt; current: array[index] = array[index-1] index -= 1 else: break array[index] = current array = [5,2,7,1,8,3,4,6,9,0]insert_sort(array) array 4.快速排序 QuickSort快速排序通常明显比同为Ο(n log n)的其他算法更快，因此常被采用，而且快排采用了分治法的思想。 步骤： 从数列中挑出一个元素作为基准数。 分区过程，将比基准数大的放到右边，小于或等于它的数都放到左边。 再对左右区间递归执行第二步，直至各区间只有一个数。 实现：123456789101112131415161718192021222324def quick_sort(array): return qsort(array, 0, len(array)-1)def qsort(array, left_index, right_index): if left_index &gt;= right_index: return array pivot = array[left_index] lp = left_index rp = right_index while lp &lt; rp: while array[rp] &gt;= pivot and lp &lt; rp: rp -= 1 while array[lp] &lt;= pivot and lp &lt; rp: lp += 1 array[lp], array[rp] = array[rp], array[lp] array[left_index], array[lp] = array[lp], array[left_index] qsort(array, left_index, lp-1) qsort(array, lp+1, right_index) return arrayarray = [5,2,7,1,8,3,4,6,9,0]quick_sort(array)array 5.归并排序 MergeSort步骤：归并排序是采用分治法的一个非常典型的应用。归并排序的思想就是先递归分解数组，再合并数组。 先考虑合并两个有序数组，基本思路是比较两个数组的最前面的数，谁小就先取谁，取了后相应的指针就往后移一位。然后再比较，直至一个数组为空，最后把另一个数组的剩余部分复制过来即可。 再考虑递归分解，基本思路是将数组分解成left和right，如果这两个数组内部数据是有序的，那么就可以用上面合并数组的方法将这两个数组合并排序。如何让这两个数组内部是有序的？可以再二分，直至分解出的小组只含有一个元素时为止，此时认为该小组内部已有序。然后合并排序相邻二个小组即可。 实现：12345678910111213141516171819202122232425def merge_sort(array): #拆分操作 if len(array) &lt;= 1: return array num = int(len(array)/2) left = merge_sort(array[ :num]) #样本量减半 right = merge_sort(array[num: ]) #样本量减半 return merge(left, right)def merge(left, right): #合并操作：外排 l, r = 0, 0 result = [] #外排需要一个装结果的辅助数组 while l&lt;len(left) and r&lt;len(right): if left[l] &lt; right[r]: result.append(left[l]) l += 1 else: result.append(right[r]) r += 1 result += left[l:] result += right[r:] return resultarray = [5,2,7,1,8,3,4,6,9,0]merge_sort(array)array 6.堆排序 HeapSort堆排序在 top K 问题中使用比较频繁。堆排序是采用二叉堆的数据结构来实现的，虽然实质上还是一维数组。二叉堆是一个近似完全二叉树 . 二叉堆具有以下性质： 父节点的键值总是大于或等于（小于或等于）任何一个子节点的键值。 每个节点的左右子树都是一个二叉堆（都是最大堆或最小堆）。 步骤： 构造最大堆（Build_Max_Heap）：若数组下标范围为0~n，考虑到单独一个元素是大根堆，则从下标n/2开始的元素均为大根堆。于是只要从n/2-1开始，向前依次构造大根堆，这样就能保证，构造到某个节点时，它的左右子树都已经是大根堆。 堆排序（HeapSort）：由于堆是用数组模拟的。得到一个大根堆后，数组内部并不是有序的。因此需要将堆化数组有序化。思想是移除根节点，并做最大堆调整的递归运算。第一次将heap[0]与heap[n-1]交换，再对heap[0…n-2]做最大堆调整。第二次将heap[0]与heap[n-2]交换，再对heap[0…n-3]做最大堆调整。重复该操作直至heap[0]和heap[1]交换。由于每次都是将最大的数并入到后面的有序区间，故操作完后整个数组就是有序的了。 最大堆调整（Max_Heapify）：该方法是提供给上述两个过程调用的。目的是将堆的末端子节点作调整，使得子节点永远小于父节点 。 123456789101112131415161718192021222324252627282930313233343536373839def heapSort(arr): for i in range(len(arr)-1): heapInsert(arr, i) #至此大根堆构造完毕，下面开始不断的取出最大值，同时调整大根堆 print("The heap has been constructed:" + str(array)) size = len(arr) arr[0], arr[size-1] = arr[size-1], arr[0] size -= 1 while size &gt; 0: heapify(arr, 0, size) # heapify后，arr[0]又是堆中的最大值 arr[0], arr[size-1] = arr[size-1], arr[0] size -= 1#创建大根堆 def heapInsert(arr, index): while arr[index] &gt; arr[int((index-1)/2)]: # (index01)/2 是父节点的下标 arr[index], arr[int((index-1)/2)] = arr[int((index-1)/2)], arr[index] index = int((index-1)/2) #堆化（就是将不是最大值的堆顶，不断下沉到应该的位置） def heapify(array, index, heap_size): leftindex = index*2 + 1 #左子节点 rightindex = leftindex + 1 #右子节点 while leftindex &lt; heap_size: largest = rightindex if ( rightindex &lt; heap_size and array[rightindex] &gt; array[leftindex] ) else leftindex largest = largest if array[largest] &gt; array[index] else index if largest == index: break array[index], array[largest] = array[largest], array[index] index = largest leftindex = index*2 + 1 rightindex = leftindex + 1array = [5,2,7,1,8,3,4,6,9,0]heapSort(array)print(array) 希尔排序 ShellSort希尔排序，也称递减增量排序算法，实质是分组插入排序。由 Donald Shell 于1959年提出。希尔排序是非稳定排序算法。 希尔排序的基本思想是：将数组列在一个表中并对列分别进行插入排序，重复这过程，不过每次用更长的列（步长更长了，列数更少了）来进行。最后整个表就只有一列了。将数组转换至表是为了更好地理解这算法，算法本身还是使用数组进行排序。 假设有这样一组数[ 13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10]如果我们以步长为5开始进行排序，我们可以通过将这列表放在有5列的表中来更好地描述算法，这样他们就应该看起来是这样：13 14 94 33 8225 59 94 65 2345 27 73 25 3910 然后我们对每列进行排序：10 14 73 25 2313 27 94 33 3925 59 94 65 8245将上述四行数字，依序接在一起时我们得到：[ 10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45 ]。这时10已经移至正确位置了，然后再以3为步长进行排序：10 14 7325 23 1327 94 3339 25 5994 65 8245排序之后变为：10 14 1325 23 3327 25 5939 65 7345 94 8294此时依序连接在一起时得到：[10, 14, 13, 25, 23, 33, 27, 25, 59, 39, 65, 73, 45, 94, 82, 94]最后以1步长进行排序（此时就是简单的插入排序了）。 实现：1234567891011121314151617def shell_sort(array): n = len(array) gap = round(n/2) #用round（）函数四舍五入 while gap&gt;0: for i in range(gap, n): temp = array[i] j = i # 插入排序中要用到的————最后插入位置的下标：j while j&gt;=gap and array[j-gap]&gt;temp: #这里用插入排序 array[j] = array[j-gap] j = j-gap array[j] = temp gap = round(gap/2) return arrayarray = [5,2,7,1,8,3,4,6,9,0]shell_sort(array) 总结下面为七种经典排序算法指标对比情况：]]></content>
      <categories>
        <category>编程</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL中InnoDB和MyISAM的联系与区别]]></title>
    <url>%2F2019%2F07%2F25%2FMySQL%E4%B8%ADInnoDB%E5%92%8CMyISAM%E7%9A%84%E8%81%94%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[&gt; InnoDB 和 MyISAM 是 MySQL 的两个「存储引擎」。 数据库存储引擎 数据库存储引擎是数据库底层软件组织，数据库管理系统（DBMS）使用数据引擎进行创建、查询、更新和删除数据。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能，使用不同的存储引擎，还可以获得特定的功能。 SHOW ENGINES; 查看自己的数据库类型 可以看出数据库为我们提供了非常多的存储引擎，从表中看出，InnoDB 的 Support 列是 DEFAULT，表明在我的数据库服务器上，InnoDB 是默认的数据库引擎，不过 MySQL 对于多引擎有很好的兼容，一个数据库服务器上不同的数据库完全可以使用不同的数据引擎，甚至一个数据库中的多个表也可以使用不同的引擎。 从一些文档中我们可以总结出这两个引擎的一些差异： InnoDB 支持事务，MyISAM 不支持，对于 InnoDB 每一条 SQL 语句都默认封装成事务进行提交，这样就会影响速度，优化速度的方式是将多条 SQL 语句放在 begin 和 commit 之间，组成一个事务； InnoDB 支持外键，而 MyISAM 不支持。 InnoDB 不支持全文索引，而 MyISAM 支持全文索引，查询效率上 MyISAM 要高； 所以如果一个表修改要求比较高的事务处理，可以选择 InnoDB。这个数据库中可以将查询要求比较高的表选择 MyISAM 存储。如果该数据库需要一个用于查询的临时表，甚至可以考虑选择 MEMORY 存储引擎。 存储引擎原理MyISAM 和 InnoDB 两种引擎所使用的索引的数据结构是什么？ 都是 B+ 树，不过区别在于： MyISAM 中 B+树的数据结构存储的内容是实际数据的地址值，它的索引和实际数据是分开的，只不过使用索引指向了实际数据。这种索引的模式被称为非聚集索引。 InnoDB 中 B+ 树的数据结构中存储的都是实际的数据，这种索引有被称为聚集索引。 B树 和 B+树 B+ 树是 B 树的一个变种，对于 B 树来说： B 树属于多叉树又名平衡多路查找树，其规则是： 所有节点关键字是按递增次序排列，并遵循左小右大原则 子节点数：非叶节点的子节点数&gt;1，且&lt;=M ，且M&gt;=2，空树除外（注：M阶代表一个树节点最多有多少个查找路径，M=M 路,当 M=2则是2 叉树,M=3 则是 3 叉） 关键字数：枝节点的关键字数量大于等于 ceil(m/2)-1 个且小于等于 M-1 个（注：ceil() 是个朝正无穷方向取整的函数 如ceil(1.1)结果为 2) 叶节点的指针为空且叶节点具有相同的深度 而对于 B+ 树： B+ 树是 B 树的一个升级版，相对于 B 树来说 B+ 树更充分的利用了节点的空间，让查询速度更加稳定，其速度完全接近于二分法查找。 索引 唯一索引：唯一索引不允许两行具有相同的索引值 主键索引：为表定义一个主键将自动创建主键索引，主键索引是唯一索引的特殊类型。主键索引要求主键中的每个值是唯一的，并且不能为空 聚集索引（Clustered)：表中各行的物理顺序与键值的逻辑（索引）顺序相同，每个表只能有一个 非聚集索引（Non-clustered)：非聚集索引指定表的逻辑顺序。数据存储在一个位置，索引存储在另一个位置，索引中包含指向数据存储位置的指针。可以有多个，小于249个 MyISAM回到 MyISAM，其索引结构如下图所示，由于 MyISAM 的索引文件仅仅保存数据记录的地址。在 MyISAM 中，主索引和辅助索引（Secondary key）在结构上没有任何区别： MyISAM 中索引检索的算法：首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址，读取相应数据记录。 InnoDB对于 InnoDB 来说，表数据文件本身就是按 B+Tree 组织的一个索引结构，这棵树的叶节点 data 域保存了完整的数据记录。由于 InnoDB 利用的数据库主键作为索引 Key，所以 InnoDB 数据表文件本身就是主索引，且因为 InnoDB 数据文件需要按照主键聚集，所以使用 InnoDB 作为数据引擎的表需要有个主键，如果没有显式指定的话 MySQL 会尝试自动选择一个可以唯一标识数据的列作为主键，如果无法找到，则会生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。]]></content>
      <categories>
        <category>编程</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python错误、调试和测试]]></title>
    <url>%2F2019%2F07%2F24%2FPython%E9%94%99%E8%AF%AF%E3%80%81%E8%B0%83%E8%AF%95%E5%92%8C%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[错误处理try…except…finally…当我们认为某些代码可能会出错时，就可以用try来运行这段代码；如果执行出错，则后续代码不会继续执行，而是直接跳转至错误处理代码，即except语句块；执行完except后，如果有finally语句块，则执行finally语句块，至此，执行完毕。 如果发生了不同类型的错误，应该由不同的except语句块处理。没错，可以有多个except来捕获不同类型的错误： 此外，如果没有错误发生，可以在except语句块后面加一个else，当没有错误发生时，会自动执行else语句： 调用栈如果错误没有被捕获，它就会一直往上抛，最后被Python解释器捕获，打印一个错误信息，然后程序退出。 比如：1234567891011$ python3 err.pyTraceback (most recent call last): File &quot;err.py&quot;, line 11, in &lt;module&gt; main() File &quot;err.py&quot;, line 9, in main bar(&apos;0&apos;) File &quot;err.py&quot;, line 6, in bar return foo(s) * 2 File &quot;err.py&quot;, line 3, in foo return 10 / int(s)ZeroDivisionError: division by zero 记录错误如果不捕获错误，自然可以让Python解释器来打印出错误堆栈，但程序也被结束了。既然我们能捕获错误，就可以把错误堆栈打印出来，然后分析错误原因，同时，让程序继续执行下去。 Python内置的logging模块可以非常容易地记录错误信息： 12345def main(): try: bar('0') except Exception as e: logging.exception(e) 同样是出错，但程序打印完错误信息后会继续执行，并正常退出： 通过配置，logging还可以把错误记录到日志文件里，方便事后排查。 抛出错误因为错误是class，捕获一个错误就是捕获到该class的一个实例。因此，错误并不是凭空产生的，而是有意创建并抛出的。Python的内置函数会抛出很多类型的错误，我们自己编写的函数也可以抛出错误。 如果要抛出错误，首先根据需要，可以定义一个错误的class，选择好继承关系，然后，用raise语句抛出一个错误的实例： 有在必要的时候才定义我们自己的错误类型。如果可以选择Python已有的内置的错误类型（比如ValueError，TypeError），尽量使用Python内置的错误类型。】 调试第一种方法简单直接粗暴有效，就是用print()把可能有问题的变量打印出来看看： 执行后在输出中查找打印的变量值： print()最大的坏处是将来还得删掉它，想想程序里到处都是print()，运行结果也会包含很多垃圾信息。所以，我们又有第二种方法。 断言凡是用print()来辅助查看的地方，都可以用断言assert来替代：1234567def foo(s): n = int(s) assert n != 0, 'n is zero!' return 10 / ndef main(): foo('0') assert的意思是，表达式n != 0应该是True，否则，根据程序运行的逻辑，后面的代码肯定会出错。 如果断言失败，assert语句本身就会抛出AssertionError： 程序中如果到处充斥着assert，和print()相比也好不到哪去。不过，启动Python解释器时可以用-O参数来关闭assert：1234$ python -O err.pyTraceback (most recent call last): ...ZeroDivisionError: division by zero 关闭后，你可以把所有的assert语句当成pass来看。 logging把print()替换为logging是第3种方式，和assert比，logging不会抛出错误，而且可以输出到文件： 123456import loggings = '0'n = int(s)logging.info('n = %d' % n)print(10 / n) logging.info()就可以输出一段文本。运行，发现除了ZeroDivisionError，没有任何信息。怎么回事？ 别急，在import logging之后添加一行配置再试试：12import logginglogging.basicConfig(level=logging.INFO) 看到输出了：123456$ python err.pyINFO:root:n = 0Traceback (most recent call last): File &quot;err.py&quot;, line 8, in &lt;module&gt; print(10 / n)ZeroDivisionError: division by zero 这就是logging的好处，它允许你指定记录信息的级别，有debug，info，warning，error等几个级别，当我们指定level=INFO时，logging.debug就不起作用了。同理，指定level=WARNING后，debug和info就不起作用了。这样一来，你可以放心地输出不同级别的信息，也不用删除，最后统一控制输出哪个级别的信息。 logging的另一个好处是通过简单的配置，一条语句可以同时输出到不同的地方，比如console和文件。 pdb第4种方式是启动Python的调试器pdb，让程序以单步方式运行，可以随时查看运行状态。我们先准备好程序：（略） IDE如果要比较爽地设置断点、单步执行，就需要一个支持调试功能的IDE。 单元测试为了编写单元测试，我们需要引入Python自带的unittest模块，编写mydict_test.py如下：编写单元测试时，我们需要编写一个测试类，从unittest.TestCase继承。以test开头的方法就是测试方法，不以test开头的方法不被认为是测试方法，测试的时候不会被执行。 对每一类测试都需要编写一个test_xxx()方法。由于unittest.TestCase提供了很多内置的条件判断，我们只需要调用这些方法就可以断言输出是否是我们所期望的。最常用的断言就是assertEqual()：1self.assertEqual(abs(-1), 1) # 断言函数返回的结果与1相等 另一种重要的断言就是期待抛出指定类型的Error: 比如通过d[&#39;empty&#39;]访问不存在的key时，断言会抛出KeyError： with12self.assertRaises(KeyError): value = d['empty'] 而通过d.empty访问不存在的key时，我们期待抛出AttributeError： 12with self.assertRaises(AttributeError): value = d.empty 运行单元测试一旦编写好单元测试，我们就可以运行单元测试。最简单的运行方式是在mydict_test.py的最后加上两行代码：12if __name__ == &apos;__main__&apos;: unittest.main() 这样就可以把mydict_test.py当做正常的python脚本运行：1$ python mydict_test.py 另一种方法是在命令行通过参数-m unittest直接运行单元测试：123456$ python -m unittest mydict_test.....----------------------------------------------------------------------Ran 5 tests in 0.000sOK 这是推荐的做法，因为这样可以一次批量运行很多单元测试，并且，有很多工具可以自动来运行这些单元测试。 setUp与tearDownsetUp()和tearDown()方法有什么用呢？设想你的测试需要启动一个数据库，这时，就可以在setUp()方法中连接数据库，在tearDown()方法中关闭数据库，这样，不必在每个测试方法中重复相同的代码： 文档测试可以把这些示例代码在Python的交互式环境下输入并执行，结果与文档中的示例代码显示的一致。 这些代码与其他说明可以写在注释中，然后，由一些工具来自动生成文档。既然这些代码本身就可以粘贴出来直接运行，那么，可不可以自动执行写在注释中的这些代码呢？ 答案是肯定的。 并且，Python内置的“文档测试”（doctest）模块可以直接提取注释中的代码并执行测试。 doctest严格按照Python交互式命令行的输入和输出来判断测试结果是否正确。只有测试异常的时候，可以用…表示中间一大段烦人的输出。 让我们用doctest来测试上次编写的Dict类：]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git学习]]></title>
    <url>%2F2019%2F03%2F15%2FGit%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[@TOC # Git廖雪峰Git教程网站 Git简介Linus一直痛恨的CVS及SVN都是集中式的版本控制系统，而Git是分布式版本控制系统 集中式和分布式版本控制系统有什么区别呢？ 集中式版本控制系统： 版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。集中式版本控制系统最大的毛病： 就是 必须联网才能工作，如果在局域网内还好，带宽够大，速度够快，可如果在互联网上，遇到网速慢的话，可能提交一个10M的文件就需要5分钟，这还不得把人给憋死啊。 首先，分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。 安装Git安装完成后，还需要最后一步设置，在命令行输入：12$ git config --global user.name &quot;Your Name&quot;$ git config --global user.email &quot;email@example.com&quot; 注意git config命令的--global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。 创建版本库首先选择一个合适的地方（win系统为例） 进入D盘，然后进入D盘的名为Git的文件夹： $ cd D: 创建一个空目录：1234$ mkdir learngit$ cd learngit$ pwd/Users/michael/learngit 第二步，通过git init命令把这个目录变成Git可以管理的仓库： 12$ git initInitialized empty Git repository in /Users/michael/learngit/.git/ 把文件添加到版本库所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。 现在我们编写一个readme.txt文件，内容如下：12Git is a version control system.Git is free software. 一定要放到learngit目录下（子目录也行），因为这是一个Git仓库，放到其他地方Git再厉害也找不到这个文件。 把一个文件放到Git仓库只需要两步。 第一步，用命令git add告诉Git，把文件添加到仓库：1$ git add readme.txt 第二步，用命令git commit告诉Git，把文件提交到仓库：1234$ git commit -m &quot;wrote a readme file&quot;[master (root-commit) eaadf4e] wrote a readme file 1 file changed, 2 insertions(+) create mode 100644 readme.txt 简单解释一下git commit命令，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。 因为commit可以一次提交很多文件，所以你可以多次add不同的文件，比如：123$ git add file1.txt$ git add file2.txt file3.txt$ git commit -m &quot;add 3 files.&quot; 时光机穿梭修改一下readme.txt文件。 运行git status命令看看结果：123456789$ git statusOn branch masterChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: readme.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) git status命令可以掌握仓库当前的状态，上面的命令输出告诉我们，readme.txt被修改过了，但还没有准备提交的修改。 git diff 可以查看上次是如何修改文件的具体内容。 知道了对readme.txt作了什么修改后，再把它提交到仓库就放心多了，提交修改和提交新文件是一样的两步：第一步git add:1$ git add readme.txt 执行第二步git commit之前，我们再运行git status看看当前仓库的状态：123456$ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) modified: readme.txt git status告诉我们，将要被提交的修改包括readme.txt 下一步，就可以放心地提交了：123$ git commit -m &quot;add distributed&quot;[master e475afc] add distributed 1 file changed, 1 insertion(+), 1 deletion(-) 此时，可用git status再次查看仓库状态：123$ git statusOn branch masternothing to commit, working tree clean Git告诉我们当前没有需要提交的修改，而且，工作目录是干净（working tree clean）的。 要随时掌握工作区的状态，使用git status命令。如果git status告诉你有文件被修改过，用git diff可以查看修改内容。 版本回退每当你觉得文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在Git中被称为commit。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个commit恢复。 版本控制系统肯定有某个命令可以告诉我们历史记录，在Git中，我们用git log命令查看： git log命令显示从最近到最远的提交日志，我们可以看到3次提交，最近的一次是append GPL，上一次是add distributed，最早的一次是wrote a readme file。 如果嫌输出信息太多，看得眼花缭乱的，可以试试加上--pretty=oneline参数：1234$ git log --pretty=onelined50eaf48d9846be0e11b46cac57cee7c11c59fd9 (HEAD -&gt; master) append GPLfdaa14c4e77cf920f438e1fe6133ecb782a72843 add distributedd0e860422fe442aa574b34a3dff10a22955300dd wrote a readme file 在Git中，用HEAD表示当前版本，也就是最新的提交d50eaf……（注意我的提交ID和你的肯定不一样），上一个版本就是 HEAD^ ，上上一个版本就是 HEAD^ ^ ，当然往上100个版本写100个^ 比较容易数不过来，所以写成HEAD~100。 把当前版本append GPL回退到上一个版本add distributed，就可以使用git reset命令：12$ git reset --hard HEAD^HEAD is now at fdaa14c add distributed 看看readme.txt的内容是不是版本add distributed： $ cat readme.txt Git is a distributed version control system. Git is free software. 此时，若想再回到最新版本 append GPL , 则需要从之前打印的日志中找出最新日志的ID序号，找到那个append GPL的commit id是d50ea，于是就可以指定回到未来的某个版本：12$ git reset --hard d50eaHEAD is now at d50eaf4 append GPL 如果中途关掉了电脑，找不到之前的日志，Git提供了一个命令git reflog用来记录你的每一次命令：123456$ git reflogd50eaf4 (HEAD -&gt; master) HEAD@&#123;0&#125;: reset: moving to d50eafdaa14c HEAD@&#123;1&#125;: reset: moving to HEAD^d50eaf4 (HEAD -&gt; master) HEAD@&#123;2&#125;: commit: append GPLfdaa14c HEAD@&#123;3&#125;: commit: add distributedd0e8604 HEAD@&#123;4&#125;: commit (initial): wrote a readme file HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset --hard commit_id。穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。 工作区和暂存区工作区（Working Directory）：就是你在电脑里能看到的目录，比如我的learngit文件夹就是一个工作区。 版本库（Repository）：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。 把文件往Git版本库里添加的时候，是分两步执行的：第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区；（用git status查看）第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。 管理修改为什么Git比其他版本控制系统设计得优秀，因为Git跟踪并管理的是修改，而非文件。 那怎么提交第二次修改呢？你可以继续git add再git commit，也可以别着急提交第一次修改，先git add第二次修改，再git commit，就相当于把两次修改合并后一块提交了： 第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git add -&gt; git commit 提交后，用git diff HEAD -- readme.txt命令可以查看工作区和版本库里面最新版本的区别： 撤销修改git checkout -- file可以丢弃工作区的修改：一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；一种是readme.txt 已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。总之，就是让这个文件回到最近一次git commit或git add时的状态。 如果修改了文件以后，并且已经git add到暂存区了用命令git reset HEAD &lt;file&gt;可以把暂存区的修改撤销掉（unstage），重新放回工作区 场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout – file。场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步:第一步用命令git reset HEAD &lt;file&gt;，就回到了场景1；第二步按场景1操作。场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。 删除文件一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用rm命令删了 $ rm test.txt 这时候Git的工作区和版本库就不一致了，可以用git status查看是哪些文件被删除了。 现在有两种选择： 确定删除：就用命令git rm删掉，并且git commit： 删错了，要恢复：根据Git的提示，用git checkout -- &lt;file&gt;...&quot;一键恢复。 远程仓库完全可以自己搭建一台运行Git的服务器，不过现阶段，为了学Git先搭个服务器绝对是小题大作。好在这个世界上有个叫GitHub的神奇的网站，从名字就可以看出，这个网站就是提供Git仓库托管服务的，所以，只要注册一个GitHub账号，就可以免费获得Git远程仓库。 由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以，需要一点设置：第1步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key： $ ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可.一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。 第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面：然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容：点“Add Key”，你就应该看到已经添加的Key： 为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。 如果你不想让别人看到Git库，有两个办法：一个是交点保护费，让GitHub把公开的仓库变成私有的，这样别人就看不见了（不可读更不可写）。另一个办法是自己动手，搭一个Git服务器，因为是你自己的Git服务器，所以别人也是看不见的。这个方法我们后面会讲到的，相当简单，公司内部开发必备。 添加远程——（先有本地库，后有远程库）首先，登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库： 在Repository name填入learngit，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库： 目前，在GitHub上的这个learngit仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库；也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。 我们根据GitHub的提示，在本地的learngit仓库下运行命令： $ git remote add origin http/SSH ##注释：HTTPS和SSH网站会自动给出。 https://github.com/server-name/repository-name.git git@github.com:server-name/repository-name.git 添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。 下一步，就可以把本地库的所有内容推送到远程库上： $ git push -u origin master 把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。 由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 从现在起，只要本地作了提交，就可以通过命令： $ git push origin master 把本地master分支的最新修改推送至GitHub 要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git；关联后，使用命令git push -u origin master第一次推送master分支的所有内容；此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改； 从远程库克隆——（先创建远程库，从远程库克隆）从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆。 首先，登陆GitHub，创建一个新的仓库，名字叫gitskills：我们勾选Initialize this repository with a README，这样GitHub会自动为我们创建一个README.md文件。创建完毕后，可以看到README.md文件： 下一步是用命令git clone克隆一个本地库：12345$ git clone git@github.com:michaelliao/gitskills.gitCloning into &apos;gitskills&apos;...remote: Counting objects: 3, done.remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 3Receiving objects: 100% (3/3), done. 进入gitskills目录看看，已经有README.md文件了 $ cd gitskills $ ls README.md 要克隆一个仓库，首先必须知道仓库的地址，然后使用git clone命令克隆。Git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快。 分支管理创建与合并分支我们把dev分支的工作成果合并到master分支上： 12345$ git merge devUpdating d46f35e..b17d20eFast-forward readme.txt | 1 + 1 file changed, 1 insertion(+) git merge命令用于合并指定分支到当前分支。合并后，再查看readme.txt的内容，就可以看到，和dev分支的最新提交是完全一样的。 注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。 当然，也不是每次合并都能Fast-forward，我们后面会讲其他方式的合并。 Git鼓励大量使用分支：查看分支：git branch创建分支：git branch &lt;name&gt;切换分支：git checkout &lt;name&gt;创建+切换分支：git checkout -b &lt;name&gt;合并某分支到当前分支：git merge &lt;name&gt;删除分支：git branch -d &lt;name&gt; 解决冲突当合并发生冲突时，查看测试文件readme.txt的内容：12345678910$ cat readme.txtGit is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files.&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADCreating a new branch is quick &amp; simple.=======Creating a new branch is quick AND simple.&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1 Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，这时打开文件编辑器，会发现文件已经被修改为上述内容。手动修改后保存。 用带参数的git log也可以看到分支的合并情况：1$ git log --graph --pretty=oneline --abbrev-commit 当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。用git log --graph命令可以看到分支合并图。 分支管理策略在实际开发中，我们应该按照几个基本原则进行分支管理： 首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活； 那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本； 你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。 所以，团队合作的分支看起来就像这样：准备合并dev分支，请注意--no-ff参数，表示禁用Fast forward： $ git merge --no-ff -m &quot;merge with no-ff&quot; dev Merge made by the &apos;recursive&apos; strategy. readme.txt | 1 + 1 file changed, 1 insertion(+) 因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。 合并分支时，加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。 可以看到，不使用Fast forward模式，merge后就像这样： Bug分支Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：12$ git stashSaved working directory and index state WIP on dev: f52c633 add merge 工作区是干净的，刚才的工作现场存到哪去了？用git stash list命令看看： 12$ git stash liststash@&#123;0&#125;: WIP on dev: f52c633 add merge 工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法： 一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除； 另一种方式是用git stash pop，恢复的同时把stash内容也删了：再用git stash list查看，就看不到任何stash内容了： 修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场。 Feature分支添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。 开发一个新feature，最好新建一个分支；如果要丢弃一个没有被合并过的分支，可以通过git branch -D &lt;name&gt;强行删除。 多人协作当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。 要查看远程库的信息，用git remote：12$ git remoteorigin 用git remote -v显示更详细的信息：123$ git remote -vorigin https://github.com/AlexGoke/Code-Practice-Python.git (fetch)origin https://github.com/AlexGoke/Code-Practice-Python.git (push) 上面显示了可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址。 推送分支推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：1$ git push origin master 如果要推送其他分支，比如dev，就改成：1$ git push origin dev 但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？ master分支是主分支，因此要时刻与远程同步； dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步； bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug； feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。 抓取分支因此，多人协作的工作模式通常是这样： 首先，可以试图用git push origin &lt;branch-name&gt;推送自己的修改； 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并； 如果合并有冲突，则解决冲突，并在本地提交； 没有冲突或者解决掉冲突后，再用git push origin &lt;branch-name&gt;推送就能成功！ 如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;。 这就是多人协作的工作模式，一旦熟悉了，就非常简单。 查看远程库信息，使用git remote -v；本地新建的分支如果不推送到远程，对其他人就是不可见的；从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交；在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致；建立本地分支和远程分支的关联，使用git branch --set-upstream branch-name origin/branch-name；从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。 Rebase rebase操作可以把本地未push的分叉提交历史整理成直线；rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。 标签管理创建标签默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？ 方法是找到历史提交的commit id，然后打上就可以了： 12345678$ git log --pretty=oneline --abbrev-commit12a631b (HEAD -&gt; master, tag: v1.0, origin/master) merged bug fix 1014c805e2 fix bug 101e1e9c68 merge with no-fff52c633 add mergecf810e4 conflict fixed5dc6824 &amp; simple14096d0 AND simple 比方说要对add merge这次提交打标签，它对应的commit id是f52c633，敲入命令： $ git tag v0.9 f52c633 注意，标签不是按时间顺序列出，而是按字母排序的。可以用git show &lt;tagname&gt;查看标签信息： 还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字： $ git tag -a v0.1 -m &quot;version 0.1 released&quot; 1094adb 命令git tag &lt;tagname&gt;用于新建一个标签，默认为HEAD，也可以指定一个commit id；命令git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;可以指定标签信息；命令git tag可以查看所有标签。 操作标签 命令git push origin &lt;tagname&gt;可以推送一个本地标签；命令git push origin --tags可以推送全部未推送过的本地标签；命令git tag -d &lt;tagname&gt;可以删除一个本地标签；命令git push origin :refs/tags/&lt;tagname&gt;可以删除一个远程标签。 使用Github 在GitHub上，可以任意Fork开源仓库；自己拥有Fork后的仓库的读写权限；可以推送pull request给官方仓库来贡献代码。]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>互联网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python定制类]]></title>
    <url>%2F2019%2F01%2F12%2Fpython%E5%AE%9A%E5%88%B6%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[定制类的目的：是为了让我们编写的类能够应用到普通的函数中，比如像len()、compare()函数这些，为了实现这个目的，就需要实现特殊方法， 定制类特殊方法比较print的结果：12345&gt;&gt;&gt;print lst[1, 2, 3]&gt;&gt;&gt;print p # p是Person类一个对象&lt; __main__.Person object at 0x10da9e850&gt; python是如何把任意变量变成str的呢？ 因为任何数据类型的实例都有一个特殊方法： str ()12345&gt;&gt;&gt;python lst.__str__()[1, 2, 3]&gt;&gt;&gt;print p.__str__() # p是Person类一个对象&lt; __main__.Person object at 0x10da9e850&gt; 如果给Person类加上 str()这个特殊方法，我们就可以按照自己的想法打印出Person的这个实例来。 123&gt;&gt;&gt;p = Person('Bob', 'male')&gt;&gt;&gt;print p&lt;Person: Bob, male&gt; python的特殊方法：用于print的 str() 用于len的 len() 用于cmp的 cmp() …… python特殊方法的特点： 特殊方法定义在class中 不需要直接调用 python的某些函数或者操作符会调用对应的特殊方法 如何正确实现特殊方法： 只需要编写用到的特殊方法 有关联性的特殊方法都必须实现(要写一个getattr ，就必须同时实现setattr() , delattr() ) Python中 str 和 repr 如果要把一个类的实例变成 str，就需要实现特殊方法str()：123456class Person(object): def __init__(self, name, gender): self.name = name self.gender = gender def __str__(self): return '(Person: %s, %s)' % (self.name, self.gender) 现在，在交互式命令行下用 print 试试：123&gt;&gt;&gt; p = Person('Bob', 'male')&gt;&gt;&gt; print p(Person: Bob, male) 如果直接敲变量 p：12&gt;&gt;&gt; p&lt;main.Person object at 0x10c941890&gt; 似乎str() 不会被调用。 因为 Python 定义了str()和repr()两种方法， str()用于显示给用户，而repr()用于显示给开发人员。 有一个偷懒的定义repr的方法：1__repr__ = __str__ Python中 cmp 对 int、str 等内置数据类型排序时，Python的 sorted() 按照默认的比较函数 cmp 排序，但是，如果对一组 Student 类的实例排序时，就必须提供我们自己的特殊方法 cmp ()：123456789101112131415class Student(object): def __init__(self, name, score): self.name = name self.score = score def __str__(self): return '(%s: %s)' % (self.name, self.score) __repr__ = __str__ def __cmp__(self, s): if self.name &lt; s.name: return -1 elif self.name &gt; s.name: return 1 else: return 0 上述 Student 类实现了cmp()方法，cmp用实例自身self和传入的实例 s 进行比较，如果 self 应该排在前面，就返回 -1，如果 s 应该排在前面，就返回1，如果两者相当，返回 0。 Student类实现了按name进行排序：123&gt;&gt;&gt; L = [Student('Tim', 99), Student('Bob', 88), Student('Alice', 77)]&gt;&gt;&gt; print sorted(L)[(Alice: 77), (Bob: 88), (Tim: 99)] 注意: 如果list不仅仅包含 Student 类，则 cmp 可能会报错： Python中len如果一个类表现得像一个list，要获取有多少个元素，就得用 len() 函数。要让 len() 函数工作正常，类必须提供一个特殊方法len()，它返回元素的个数。例如，我们写一个 Students 类，把名字传进去：12345class Students(object): def __init__(self, *args): self.names = args def __len__(self): return len(self.names) 只要正确实现了len()方法，就可以用len() 函数返回Students实例的“长度”：1234&gt;&gt;&gt; ss = Students('Bob', 'Alice', 'Tim')&gt;&gt;&gt; print len(ss)3 知识点回顾： 可变参数——python基础语法如果想让一个函数接受任意个参数，可以顶一个可变参数。可变参数名字前面有个号，可传入多个参数给可变参数。`def fn(args)print args`Python解释器会把传入的一组参数组装成一个tuple传递给可变参数，因此，在函数内部，直接把变量args看成一个tuple就好了。 Python中数学运算Python 提供的基本数据类型 int、float 可以做整数和浮点的四则运算以及乘方等运算。 但是，四则运算不局限于int和float，还可以是有理数、矩阵等。 要表示有理数，可以用一个Rational类来表示：1234class Rational(object): def __init__(self, p, q): self.p = p self.q = q p、q 都是整数，表示有理数 p/q。 如果要让Rational进行+运算，需要正确实现add：123456789class Rational(object): def __init__(self, p, q): self.p = p self.q = q def __add__(self, r): return Rational(self.p * r.q + self.q * r.p, self.q * r.q) def __str__(self): return '%s/%s' % (self.p, self.q) __repr__ = __str__ 现在可以试试有理数加法： 1234&gt;&gt;&gt; r1 = Rational(1, 3)&gt;&gt;&gt; r2 = Rational(1, 2)&gt;&gt;&gt; print r1 + r25/6 实现Rational类的四则运算：加法：add减法：sub乘法：mul除法：div1234567891011121314151617181920212223def gcd(a, b): #约分，找出分子分母的最大公约数 if b == 0: return a return gcd(b, a % b) class Rational(object): def __init__(self, p, q): self.p = p self.q = q def __add__(self, r): return Rational(self.p * r.q + self.q * r.p, self.q * r.q) def __sub__(self, r): return Rational(self.p * r.q - self.q * r.p, self.q * r.q) def __mul__(self, r): return Rational(self.p * r.p, self.q * r.q) def __div__(self, r): return Rational(self.p * r.q, self.q * r.p) def __str__(self): g = gcd(self.p, self.q) #分子分母的最大公约数g return '%s/%s' % (self.p / g, self.q / g) __repr__ = __str__ 测试结果如下：1234567891011r1 = Rational(1, 2)r2 = Rational(1, 4)print r1 + r2print r1 - r2print r1 * r2print r1 / r23/41/41/82/1 python中类型转换Rational类实现了有理数运算，但是，如果要把结果转为 int 或 float 怎么办？ 已学过整数和浮点数的转换： &gt;&gt;&gt; int(12.34) 12 &gt;&gt;&gt; float(12) 12.0 如果要把 Rational 转为 int，应该使用： r = Rational(12, 5) n = int(r) 要让 int() 函数正常工作，只需要实现特殊方法int():同理，要让 float() 函数正常工作，只需要实现特殊方法float()。12345678class Rational(object): def __init__(self, p, q): self.p = p self.q = q def __int__(self): return self.p // self.q def __float__(self): return float(self.p) / self.q 结果如下：12345678&gt;&gt;&gt; print int(Rational(7, 2))3&gt;&gt;&gt; print int(Rational(1, 3))0 &gt;&gt;&gt;print float(Rational(7, 2))3.5&gt;&gt;&gt;print float(Rational(1, 3))0.333333333333 python中 @property 类比C#中的 属性get/set, get读取属性值，set设置属性值 当我们想要修改一个 Student 的 scroe 属性时，可以这么写：123s = Student('Bob', 59)s.score = 60s.score = 1000 显然，直接给属性赋值无法检查分数的有效性。 如果利用两个方法：12345678910class Student(object): def __init__(self, name, score): self.name = name self.__score = score def get_score(self): return self.__score def set_score(self, score): if score &lt; 0 or score &gt; 100: raise ValueError('invalid score') self.__score = score 这样一来，s.set_score(1000) 就会报错。 这种使用 get/set 方法来封装对一个属性的访问在许多面向对象编程的语言中都很常见。 但是写 s.get_score() 和 s.set_score() 没有直接写 s.score 来得直接。 有一个两全其美的方法——因为Python支持高阶函数，在函数式编程中我们介绍了装饰器函数，可以用装饰器函数把 get/set 方法装饰成属性调用：1234567891011121314151617181920class Student(object): def __init__(self, name, score): self.name = name self.__score = score @property def score(self): return self.__score @score.setter def score(self, score): if score &lt; 0 or score &gt; 100: raise ValueError('invalid score') self.__score = score #自定义grade属性，可根据score计算A、B、C @property def grade(self): if self.score &lt; 60: return 'C' if self.score &lt; 80: return 'B' return 'A' 注意: 第一个score(self)是get方法，用@property装饰；第二个score(self, score)是set方法，用@score.setter装饰，@score.setter是前一个@property装饰后的副产品。现在，就可以像使用属性一样设置score了： 结果如下：12345678910&gt;&gt;&gt; s = Student(&apos;Bob&apos;, 59)&gt;&gt;&gt; s.score = 60&gt;&gt;&gt; print s.score60&gt;&gt;&gt; s.score = 1000Traceback (most recent call last): ...ValueError: invalid score&gt;&gt;&gt;print s.gradeB 说明对 score 赋值实际调用的是 set方法。 python中 slots由于Python是动态语言，任何实例在运行期都可以动态地添加属性。 如果要限制添加的属性，例如，Student类只允许添加 name、gender和score 这3个属性，就可以利用Python的一个特殊的slots来实现。 slots是指一个类允许的属性列表：123456class Student(object): __slots__ = ('name', 'gender', 'score') def __init__(self, name, gender, score): self.name = name self.gender = gender self.score = score 测试结果如下：s 123456&gt;&gt;&gt; s.name = &apos;Tim&apos; # OK&gt;&gt;&gt; s.score = 99 # OK&gt;&gt;&gt; s.grade = &apos;A&apos;Traceback (most recent call last): ...AttributeError: &apos;Student&apos; object has no attribute &apos;grade&apos; slots的目的是限制当前类所能拥有的属性，如果不需要添加任意动态的属性，使用slots也能节省内存。 应用: 假设Person类通过slots定义了name和gender，请在派生类Student中通过slots继续添加score的定义，使Student类可以实现name、gender和score 3个属性。Student类的slots只需要包含Person类不包含的score属性即可。1234567891011121314151617181920class Person(object): __slots__ = ('name', 'gender') def __init__(self, name, gender): self.name = name self.gender = genderclass Student(Person): __slots__ = ('score',) #name, gender不用再写出来 def __init__(self, name, gender, score): super(Student, self).__init__(name, gender) #super.__init()初始化父类属性，不要忘记调用！ self.score = scores = Student('Bob', 'male', 59)s.name = 'Tim's.score = 99print s.score python中 call在Python中，函数其实是一个对象：12345&gt;&gt;&gt; f = abs&gt;&gt;&gt; f.__name__&apos;abs&apos;&gt;&gt;&gt; f(-123)123 由于 f 可以被调用，所以，f 被称为可调用对象。 所有的函数都是可调用对象。 一个类实例也可以变成一个可调用对象，只需要实现一个特殊方法call()。 我们把 Person 类变成一个可调用对象： 这样就可以 调用函数 那样来 调用一个类对象实例 首先把Person类变成一个可调用对象：12345678class Person(object): def __init__(self, name, gender): self.name = name self.gender = gender def __call__(self, friend): print 'My name is %s...' % self.name print 'My friend is %s...' % friend 现在可以对 Person 实例直接调用：1234&gt;&gt;&gt; p = Person(&apos;Bob&apos;, &apos;male&apos;)&gt;&gt;&gt; p(&apos;Tim&apos;)My name is Bob...My friend is Tim... 注意： 单看 p(‘Tim’) 你无法确定 p 是一个函数还是一个类实例，所以，在Python中，函数也是对象，对象和函数的区别并不显著。 之前写过一个斐波那契数列函数：class Fib(object):现在加一个call方法，让调用可以更简单：12345678910class Fib(object): def __call__(self, num): a, b, L = 0, 1, [] for n in range(num): L.append(a) a, b = b, a+b return Lf = Fib()print f(10) #调用Fib类就像调用函数一样，非常方便 总结语法到此基本学完，下面就可以学一些更深层的内容，比如：IO：文件和Socket多任务：进程和线程数据库： python支持一个通用的db API，可以连接各种不同的关系数据库。Web开发：可以构建一个基于Web的服务，]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP状态码302解决方法]]></title>
    <url>%2F2019%2F01%2F09%2FHTTP%E7%8A%B6%E6%80%81%E7%A0%81302%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[HTTP错误码302解决办法问题描述在制作网站的登录系统时，经测试发现，无法成功的从主页登录至个人页面，返回结果的HTTP状态码如下：12127.0.0.1 - - [09/Jan/2019 09:08:31] "GET /index HTTP/1.1" 302 -127.0.0.1 - - [09/Jan/2019 09:08:31] "GET /login?next=%2Findex HTTP/1.1" 200 - 注：/login为登录页面， /index为成功登录后的个人页面 第一个返回结果表示跳转/index个人页面时，发生了302 Found-临时性重定向。第二个返回结果表示跳转/login登录页面时，发生200 OK, 表示从客户端发来的请求在服务器端被正常处理了。所以又回到了登录页面。 302定义 302 : 302 代表暂时性转移(Temporarily Moved )。该状态码表示请求的资源已被分配了新的URI，希望用户（本次）能使用新的URI访问。 意思就是你访问网址A，但是网址A因为服务器端的拦截器或者其他后端代码处理的原因，会被重定向到网址B。 解决方法我这里出现302错误的原因是由于我的后端代码写了从OpenID获取用户名和邮箱后，==对邮箱email进行验证==，若数据库中不存在该用户，则当作新用户处理，分别将从OpenID中获取的用户名nickname和邮箱email存入数据库。 12345678910111213141516171819202122#登录回调函数@oid.after_logindef after_login(resp): #resp参数传递给after_login()函数，它包含了从OpenID提供商返回来的信息，上面设置需要返回的信息是：nickname, email if resp.email is None or resp.email == "": flash('Invalid login. Please try again.') return redirect(url_for('login')) user = User.query.filter_by(emile=resp.emil).first() #从数据库中搜索邮箱地址 if user is None: #如果用户不存在，说明是一个新用户，添加一个新用户到数据库 nickname = resp.nickname if nickname is None or nickname == "": nickname =resp.email.spilt('@')[0] user = User(nickname = nickname, email = resp.email) db.session.add(user) db.session.commit() remember_me = False if 'remember_me' in session: remember_me = session[ 'remember_me' ] session.pop('remember_me', None) login_user(user, remember = remember_me) #为了注册这个有效的登录，调用Flask-Login的login_user函数 return redirect(request.args.get('next') or url_for('index')) 测试始终不成功，无法成功登录： 从代码逻辑出发考虑：可能是从OpenID获取的数据有问题，也将无法再与数据库进行判断。尝试将判断邮箱改为判断用户名（emil改为nickname）123456789#登录回调函数@oid.after_logindef after_login(resp): if resp.nickname is None or resp.nickname == "": flash('Invalid login. Please try again.') return redirect(url_for('login')) user = User.query.filter_by(nickname=resp.nickname).first() #从数据库中搜索用户名信息………… 测试后成功登录： 说明从OpenID请求发回的数据是没有email信息的，程序逻辑进入了回到登录页/login 为什么从OpenID返回的信息没有email呢？ （还不清楚）]]></content>
      <categories>
        <category>Python</category>
        <category>Flask</category>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>编程</tag>
        <tag>Flask</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python类的继承]]></title>
    <url>%2F2018%2F12%2F23%2Fpython%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[类的继承 总是从某个类继承，如果没有具体父类的话，那么都是从object继承。12class MyClass(object): pass 不要忘记调用super(). init 用来初始化父类的，如果忘记调用，那么父类的属性就可能没有被初始化。123def __init__(self, args): super(SubClass, self).__init__(args) pass python中继承一个类如果已经定义了Person类，需要定义新的Student和Teacher类时，可以直接从Person类继承： 1234class Person(object): def __init__(self, name, gender): self.name = name self.gender = gender 定义Student类时，只需要把额外的属性加上，例如score：1234class Student(Person): def __init__(self, name, gender, score): super(Student, self).__init__(name, gender) self.score = score 一定要用 super(Student, self).init(name, gender) 去初始化父类，否则，继承自 Person 的 Student 将没有 name 和 gender。 函数super(Student, self) 将返回当前类继承的父类，即 Person ，然后调用init()方法，注意self参数已在super()中传入，在init()中将隐式传递，不需要写出（也不能写）。 4.2 python中判断类型函数isinstance()可以判断一个变量的类型，既可以用在Python内置的数据类型如str、list、dict，也可以用在我们自定义的类，它们本质上都是数据类型。假设有如下的 Person、Student 和 Teacher 的定义及继承关系如下：123p = Person('Tim', 'Male')s = Student('Bob', 'Male', 88)t = Teacher('Alice', 'Female', 'English') 当我们拿到变量 p、s、t 时，可以使用 isinstance 判断类型：123456&gt;&gt;&gt; isinstance(p, Person)True # p是Person类型&gt;&gt;&gt; isinstance(p, Student)False # p不是Student类型&gt;&gt;&gt; isinstance(p, Teacher)False # p不是Teacher类型 4.3 python中多态类具有继承关系，并且子类类型可以向上转型看做父类类型，如果我们从 Person 派生出 Student和Teacher ，并都写了一个 whoAmI() 方法：1234567891011121314151617181920class Person(object): def __init__(self, name, gender): self.name = name self.gender = gender def whoAmI(self): return 'I am a Person, my name is %s' % self.nameclass Student(Person): def __init__(self, name, gender, score): super(Student, self).__init__(name, gender) self.score = score def whoAmI(self): return 'I am a Student, my name is %s' % self.nameclass Teacher(Person): def __init__(self, name, gender, course): super(Teacher, self).__init__(name, gender) self.course = course def whoAmI(self): return 'I am a Teacher, my name is %s' % self.name 在一个函数中，如果我们接收一个变量 x，则无论该 x 是 Person、Student还是 Teacher，都可以正确打印出结果：12345678910def who_am_i(x): print x.whoAmI()p = Person('Tim', 'Male')s = Student('Bob', 'Male', 88)t = Teacher('Alice', 'Female', 'English')who_am_i(p)who_am_i(s)who_am_i(t) 运行结果：123I am a Person, my name is TimI am a Student, my name is BobI am a Teacher, my name is Alice 这种行为称为多态。也就是说，方法调用将作用在 x 的实际类型上。s 是Student类型，它实际上拥有自己的 whoAmI() 方法以及从 Person继承的 whoAmI方法，但调用 s.whoAmI() 总是先查找它自身的定义，如果没有定义，则顺着继承链向上查找，直到在某个父类中找到为止。 由于Python是动态语言，所以，传递给函数 who_am_i(x) 的参数 x 不一定是 Person 或 Person 的子类型。任何数据类型的实例都可以，只要它 有一个whoAmI() 的方法即可： 这是动态语言和静态语言（例如Java）最大的差别之一。动态语言调用实例方法，不检查类型，只要方法存在，参数正确，就可以调用。 python中多重继承除了从一个父类继承外，Python允许从多个父类继承，称为多重继承。 多重继承的继承链就不是一棵树了，它像这样：12345678910111213141516171819class A(object): def __init__(self, a): print 'init A...' self.a = aclass B(A): def __init__(self, a): super(B, self).__init__(a) print 'init B...'class C(A): def __init__(self, a): super(C, self).__init__(a) print 'init C...'class D(B, C): def __init__(self, a): super(D, self).__init__(a) print 'init D...' 如图所示： 像这样，D 同时继承自 B 和 C，也就是 D 拥有了 A、B、C 的全部功能。多重继承通过 super() 调用init()方法时，A 虽然被继承了两次，但init()只调用一次：12345&gt;&gt;&gt; d = D('d')init A...init C...init B...init D... 多重继承的目的是从两种继承树中分别选择并继承出子类，以便组合功能使用。 python中获取对象信息拿到一个变量，除了用 isinstance() 判断它是否是某种类型的实例外，还有没有别的方法获取到更多的信息呢？ 首先可以用 type() 函数获取变量的类型，它返回一个 Type 对象：12345&gt;&gt;&gt; type(123)&lt;type 'int'&gt;&gt;&gt;&gt; s = Student('Bob', 'Male', 88)&gt;&gt;&gt; type(s)&lt;class '__main__.Student'&gt; 其次，可以用 dir() 函数获取变量的所有属性：12345&gt;&gt;&gt; dir(123) # 整数也有很多属性...['__abs__', '__add__', '__and__', '__class__', '__cmp__', ...]&gt;&gt;&gt; dir(s)['__class__', '__delattr__', '__dict__', '__doc__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'gender', 'name', 'score', 'whoAmI'] 对于实例变量，dir() 返回所有实例属性，包括__class__这类有特殊意义的属性。注意到方法whoAmI也是 s 的一个属性。 如何去掉__xxx__这类的特殊属性，只保留我们自己定义的属性？回顾一下filter() 函数的用法。 dir() 返回的属性是字符串列表，如果已知一个属性名称，要获取或者设置对象的属性，就需要用 getattr() 和 setattr( ) 函数了：123456789101112131415&gt;&gt;&gt; getattr(s, 'name') # 获取name属性'Bob'&gt;&gt;&gt; setattr(s, 'name', 'Adam') # 设置新的name属性&gt;&gt;&gt; s.name'Adam'&gt;&gt;&gt; getattr(s, 'age') # 获取age属性，但是属性不存在，报错：Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;AttributeError: 'Student' object has no attribute 'age'&gt;&gt;&gt; getattr(s, 'age', 20) # 获取age属性，如果属性不存在，就返回默认值20：20 任务：对于Person类的定义： class Person(object): def __init__(self, name, gender): self.name = name self.gender = gender 希望除了 name和gender 外，可以提供任意额外的关键字参数，并绑定到实例，请修改 Person 的 init()定 义，完成该功能。 传入**kw 即可传入任意数量的参数，并通过 setattr() 绑定属性。123456789class Person(object): def __init__(self, name, gender, **kw): for k, v in kw.iteritems(): setattr(self, k, v)p = Person('Bob', 'Male', age=18, course='Python')print p.ageprint p.course]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python面向对象编程]]></title>
    <url>%2F2018%2F12%2F22%2Fpython%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[面向对象编程python之定义类并创建实例在Python中，类通过 class 关键字定义。12class Person(object): pass 按照 Python 的编程习惯，类名以大写字母开头，紧接着是(object)，表示该类是从哪个类继承下来的。类的继承将在后面的章节讲解，现在我们只需要简单地从object类继承。有了Person类的定义，就可以创建出具体的xiaoming、xiaohong等实例。创建实例使用 类名+()，类似函数调用的形式创建：12xiaoming = Person()xiaohong = Person() python中创建实例属性虽然可以通过Person类创建出xiaoming、xiaohong等实例，但是这些实例看上除了地址不同外，没有什么其他不同。如何让每个实例拥有各自不同的属性？由于Python是动态语言，对每一个实例，都可以直接给他们的属性赋值，例如，给xiaoming这个实例加上name、gender和birth属性：1234xiaoming = Person()xiaoming.name = 'Xiao Ming'xiaoming.gender = 'Male'xiaoming.birth = '1990-1-1' python中初始化实例属性现实世界中，一种类型的实例应该拥有相同名字的属性。在定义 Person 类时，可以为Person类添加一个特殊的init()方法，当创建实例时，init()方法被自动调用，我们就能在此为每个实例都统一加上以下属性：12345class Person(object): def __init__(self, name, gender, birth): self.name = name self.gender = gender self.birth = birth init() 方法的第一个参数必须是 self（也可以用别的名字，但建议使用习惯用法），后续参数则可以自由指定，和定义函数没有任何区别。相应地，创建实例时，就必须要提供除 self 以外的参数：12xiaoming = Person('Xiao Ming', 'Male', '1991-1-1')xiaohong = Person('Xiao Hong', 'Female', '1992-2-2') 有了init()方法，每个Person实例在创建时，都会有 name、gender 和 birth 这3个属性，并且，被赋予不同的属性值，访问属性使用.操作符： 任务：请定义Person类的init方法，除了接受 name、gender 和 birth 外，还可接受任意关键字参数，并把他们都作为属性赋值给实例。 要定义关键字参数，使用 **kw；除了可以直接使用 self.name = ‘xxx’ 设置一个属性外，还可以通过 setattr(self, ‘name’, ‘xxx’) 设置属性。 12345678class Person(object): def __init__(self, name, gender, birth, **kw): self.name = name self.gender = gender self.birth = birth for k, v in kw.iteritems(): setattr(self, k, v)xiaoming = Person('Xiao Ming', 'Male', '1990-1-1', job='Student') python中访问限制 Python对属性权限的控制是通过属性名来实现的，如果一个属性由双下划线开头(__)，该属性就无法被外部访问。[类比C#中 私有变量private] 看例子： 123456789101112 class Person(object): def __init__(self, name): self.name = name self._title = 'Mr' self.__job = 'Student'p = Person('Bob')print p.name =&gt; Bobprint p._title =&gt; Mrprint p.__job =&gt; Error 可见，只有以双下划线开头的 “__job” 不能直接被外部访问。 但是，如果一个属性以xxx 的形式定义，那它又可以被外部访问了，以xxx定义的属性在Python的类中被称为特殊属性，有很多预定义的特殊属性可以使用，通常我们不要把普通属性用xxx定义。 以单下划线开头的属性”_xxx”虽然也可以被外部访问，但是，按照习惯，他们不应该被外部访问。 python中创建类属性 类是模板，而实例则是根据类创建的对象。 绑定在一个实例上的属性不会影响其他实例，但是，类本身也是一个对象，如果在类上绑定一个属性，则所有实例都可以访问类的属性，并且，所有实例访问的类属性都是同一个！也就是说，实例属性每个实例各自拥有，互相独立，而类属性有且只有一份。 定义类属性可以直接在 class 中定义： 1234class Person(object): address = 'Earth' def __init__(self, name): self.name = name 因为类属性是直接绑定在类上的，所以，访问类属性不需要创建实例，就可以直接访问： 12print Person.address=&gt; Earth 对一个实例调用类的属性也是可以访问的，所有实例都可以访问到它所属的类的属性： 由于Python是动态语言，类属性也是可以动态添加和修改的： 12345 Person.address = 'China'print p1.address =&gt; 'China'print p2.address =&gt; 'China' 因为类属性只有一份，所以，当Person类的address改变时，所有实例访问到的类属性都改变了。 任务：请给 Person 类添加一个类属性 count，每创建一个实例，count 属性就加 1，这样就可以统计出一共创建了多少个 Person 的实例。 由于创建实例必定会调用init()方法，所以在这里修改类属性 count 很合适。 12345class Person(object): count = 0 def __init__(self, name): Person.count = Person.count + 1 self.name = name python中类属性和实例属性名字冲突怎么办 修改类属性会导致所有实例访问到的类属性全部都受影响，但是，如果在实例变量上修改类属性会发生什么问题呢？1234567891011121314class Person(object): address = 'Earth' def __init__(self, name): self.name = namep1 = Person('Bob')p2 = Person('Alice')print 'Person.address = ' + Person.addressp1.address = 'China'print 'p1.address = ' + p1.addressprint 'Person.address = ' + Person.addressprint 'p2.address = ' + p2.address 结果如下：1234Person.address = Earthp1.address = ChinaPerson.address = Earthp2.address = Earth 我们发现，在设置了 p1.address = ‘China’ 后，p1访问 address 确实变成了 ‘China’，但是，Person.address和p2.address仍然是’Earch’，怎么回事？原因是 p1.address = ‘China’并没有改变 Person 的 address，而是给 p1这个实例绑定了实例属性address ，对p1来说，它有一个实例属性address（值是’China’），而它所属的类Person也有一个类属性address，所以:访问 p1.address 时，优先查找实例属性，返回’China’。访问 p2.address 时，p2没有实例属性address，但是有类属性address，因此返回’Earth’。可见，当实例属性和类属性重名时，实例属性优先级高，它将屏蔽掉对类属性的访问。可见，千万不要在实例上修改类属性，它实际上并没有修改类属性，而是给实例绑定了一个实例属性。 python中定义实例方法 一个实例的私有属性就是以__开头的属性，无法被外部访问，那这些属性定义有什么用？虽然私有属性无法从外部访问，但是，从类的内部是可以访问的。除了可以定义实例的属性外，还可以定义实例的方法。 实例的方法就是在类中定义的函数，它的第一个参数永远是 self，指向调用该方法的实例本身，其他参数和一个普通函数是完全一样的：1234567class Person(object): def __init__(self, name): self.__name = name def get_name(self): return self.__name get_name(self) 就是一个实例方法，它的第一个参数是self。init (self, name) 其实也可看做是一个特殊的实例方法。 调用实例方法必须在实例上调用：123p1 = Person('Bob')print p1.get_name() # self不需要显式传入=&gt; Bob 在实例方法内部，可以访问所有实例属性，这样，如果外部需要访问私有属性，可以通过方法调用获得，这种数据封装的形式除了能保护内部数据一致性外，还可以简化外部调用的难度。 python中方法也是属性我们在 class 中定义的实例方法其实也是属性，它实际上是一个函数对象：1234567891011121314class Person(object): def __init__(self, name, score): self.name = name self.score = score def get_grade(self): return 'A'p1 = Person('Bob', 90)print p1.get_grade=&gt; &lt;bound method Person.get_grade of &lt;__main__.Person object at 0x109e58510&gt;&gt;print p1.get_grade() =&gt; A p1.get_grade 返回的是一个函数对象，但这个函数是一个绑定到实例的函数，p1.get_grade() 才是方法调用。 因为方法也是一个属性，所以，它也可以动态地添加到实例上，只是需要用 types.MethodType() 把一个函数变为一个方法：(给一个实例动态添加方法并不常见，直接在class中定义要更直观。)——略 python中定义类方法和属性类似，方法也分实例方法和类方法。 在class中定义的全部是实例方法，实例方法第一个参数 self 是实例本身。 要在class中定义类方法，需要这么写：12345678class Person(object): count = 0 @classmethod def how_many(cls): return cls.count def __init__(self, name): self.name = name Person.count = Person.count + 1 通过标记一个 @classmethod，该方法将绑定到 Person 类上，而非类的实例。类方法的第一个参数将传入类本身，通常将参数名命名为 cls，上面的 cls.count 实际上相当于 Person.count。 因为是在类上调用，而非实例上调用，因此类方法无法获得任何实例变量，只能获得类的引用。[类比C#里的静态函数（static function)]]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python模块]]></title>
    <url>%2F2018%2F12%2F22%2Fpython%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[@TOC 模块 模块 和 包 的概念:-将代码放入多个py文件，同一个名字变量互不影响-模块名字就是 py文件的文件名1234&gt; #test.py 自身模块名test&gt; import math 引用math模块&gt; print math.pow(2, 10) 调用math模块的函数&gt; 模块多了以后，也容易重名，解决办法就是放入不同的包1234&gt; # test.py 自身模块名&gt; import p1.util 引用p1.util模块, p1是包&gt; print p1.util.f(2, 10) 调用p1.util模块的f函数&gt; 在文件系统中，包就是文件夹，模块就是XXX.py文件包可以有多级如何去分包和普通目录：包下面有个init.py注意每层包的每层目录都要有这个文件！ python之导入模块要使用一个模块，我们必须首先导入该模块。Python使用import语句导入一个模块。例如，导入系统自带的模块 math：1import math 你可以认为math就是一个指向已导入模块的变量，通过该变量，我们可以访问math模块中所定义的所有公开的函数、变量和类：1234&gt;&gt;&gt; math.pow(2, 0.5) # pow是函数1.4142135623730951&gt;&gt;&gt; math.pi # pi是变量3.141592653589793 如果我们只希望导入用到的math模块的某几个函数，而不是所有函数，可以用下面的语句：1from math import pow, sin, log 如果使用import导入模块名，由于必须通过模块名引用函数名，因此不存在冲突：123import math, loggingprint math.log(10) # 调用的是math的log函数logging.log(10, 'something') # 调用的是logging的log函数 如果使用 from…import 导入 log 函数，势必引起冲突。这时，可以给函数起个“别名”来避免冲突：1234from math import logfrom logging import log as logger # logging的log现在变成了loggerprint log(10) # 调用的是math的loglogger(10, 'import from logging') # 调用的是logging的log python中动态导入模块有的时候，两个不同的模块提供了相同的功能，比如 StringIO 和 cStringIO 都提供了StringIO这个功能。这是因为Python是动态语言，解释执行，因此Python代码运行速度慢。如果要提高Python代码的运行速度，最简单的方法是把某些关键函数用 C 语言重写，这样就能大大提高执行速度。同样的功能，StringIO 是纯Python代码编写的，而 cStringIO 部分函数是 C 写的，因此 cStringIO 运行速度更快。利用ImportError错误，我们经常在Python中动态导入模块：1234try: from cStringIO import StringIOexcept ImportError: from StringIO import StringIO 上述代码先尝试从cStringIO导入，如果失败了（比如cStringIO没有被安装），再尝试从StringIO导入。这样，如果cStringIO模块存在，则我们将获得更快的运行速度，如果cStringIO不存在，则顶多代码运行速度会变慢，但不会影响代码的正常执行。 python之使用futurePython的新版本会引入新的功能，但是，实际上这些功能在上一个老版本中就已经存在了。要“试用”某一新的特性，就可以通过导入future模块的某些功能来实现。Python 2.7的整数除法运算结果仍是整数：Python 3.x已经改进了整数的除法运算，“/”除将得到浮点数，“//”除才仍是整数：1234&gt;&gt;&gt; 10 / 33.3333333333333335&gt;&gt;&gt; 10 // 33 要在Python 2.7中引入3.x的除法规则，导入future的division：123&gt;&gt;&gt; from __future__ import division&gt;&gt;&gt; print 10 / 33.3333333333333335 当新版本的一个特性与旧版本不兼容时，该特性将会在旧版本中添加到future中，以便旧的代码能在旧版本中测试新特性。 python之安装第三方模块 python提供的模块管理工具： easy_install pip （推荐，已内置到python2.7.9）]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python函数式编程]]></title>
    <url>%2F2018%2F12%2F22%2Fpython%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[函数式编程是一种范式，不同于函数把计算视为函数而非指令；纯函数式编程：不需要变量，没有副作用，测试简单；支持高阶函数，代码简洁。 @TOC 函数式编程简介 函数： function函数式：functional，一种编程范式 函数式编程特点：把计算视为函数而非指令；纯函数式编程：不需要变量，没有副作用，测试简单；支持高阶函数，代码简洁 高阶函数变量可以指向函数函数名其实就是指向函数的变量高阶函数：能接收函数作为参数的函数 12345&gt;&gt;&gt;def add(x, y, f):... return f(x)+f(y)...&gt;&gt;&gt;add(-5, 9, abs)14 （这就是一个高阶函数的例子，变量f指向函数abs） map() 函数python内置的高阶函数，它接收一个函数 f 和一个 list，并通过把函数 f 依次作用在 list 的每个元素上，得到一个新的 list 并返回。注意：map()函数不改变原有的 list，而是返回一个新的 list。 reduce() 函数也是Python内置的一个高阶函数。reduce()函数接收的参数和 map()类似，一个函数 f，一个list，但行为和 map()不同，reduce()传入的函数 f 必须接收两个参数，reduce()对list的每个元素反复调用函数f，并返回最终结果值。 调用 reduce(f, [1, 3, 5, 7, 9])时，reduce函数将做如下计算：先计算头两个元素：f(1, 3)，结果为4；再把结果和第3个元素计算：f(4, 5)，结果为9；再把结果和第4个元素计算：f(9, 7)，结果为16；再把结果和第5个元素计算：f(16, 9)，结果为25；由于没有更多的元素了，计算结束，返回结果25。 reduce()还可以接收第3个可选参数，作为计算的初始值。如果把初始值设为100，计算： filter() 函数是 Python 内置的另一个有用的高阶函数，filter()函数接收一个函数 f 和一个list，这个函数 f 的作用是对每个元素进行判断，返回 True或 False，filter()根据判断结果自动过滤掉不符合条件的元素，返回由符合条件元素组成的新list。利用filter()，可以完成很多有用的功能，例如，删除 None 或者空字符串： 1234def is_not_empty(s): return s and len(s.strip()) &gt; 0filter(is_not_empty, ['test', None, '', 'str', ' ', 'END'])结果：['test', 'str', 'END'] 注意: s.strip(rm) 删除 s 字符串中开头、结尾处的 rm 序列的字符。当rm为空时，默认删除空白符（包括’\n’, ‘\r’, ‘\t’, ‘ ‘) 123a='\t\t123\r\n'a.strip()结果：'123' Python内置的 sorted() 函数可对list进行排序：但 sorted()也是一个高阶函数，它可以接收一个比较函数来实现自定义排序，比较函数的定义是，传入两个待比较的元素 x, y，如果 x 应该排在 y 的前面，返回 -1，如果 x 应该排在 y 的后面，返回 1。如果 x 和 y 相等，返回 0。因此，如果我们要实现倒序排序，只需要编写一个reversed_cmp函数：这样，调用 sorted() 并传入 reversed_cmp 就可以实现倒序排序：12345678def reversed_cmp(x, y): if x &gt; y: return -1 if x &lt; y: return 1 return 0 &gt;&gt;&gt;sorted([36, 5, 12, 9, 21], reversed_cmp)[36, 21, 12, 9, 5] python中返回函数Python的函数不但可以返回int、str、list、dict等数据类型，还可以返回函数！例如，定义一个函数 f()，我们让它返回一个函数 g，可以这样写：1234567def f(): print 'call f()...' # 定义函数g: def g(): print 'call g()...' # 返回函数g: return g 调用函数 f，我们会得到 f 返回的一个函数：123456&gt;&gt;&gt; x = f() # 调用f()call f()...&gt;&gt;&gt; x # 变量x是f()返回的函数：&lt;function g at 0x1037bf320&gt;&gt;&gt;&gt; x() # x指向函数，因此可以调用call g()... # 调用x()就是执行g()函数定义的代码 python中闭包在函数内部定义的函数和外部定义的函数是一样的，只是他们无法被外部访问：123456def g(): print 'g()...'def f(): print 'f()...' return g 将 g 的定义移入函数 f 内部，防止其他代码调用 g：12345def f(): print 'f()...' def g(): print 'g()...' return g 但是，考察上一小节定义的 calc_sum 函数：1234def calc_sum(lst): def lazy_sum(): return sum(lst) return lazy_sum 注意: 发现没法把 lazy_sum 移到 calc_sum 的外部，因为它引用了 calc_sum 的参数 lst。 像这种内层函数引用了外层函数的变量（参数也算变量），然后返回内层函数的情况，称为闭包（Closure）。 闭包的特点是返回的函数还引用了外层函数的局部变量，所以，要正确使用闭包，就要确保引用的局部变量在函数返回后不能变。举例如下：123456789#希望一次返回3个函数，分别计算1x1,2x2,3x3:def count(): fs = [] for i in range(1, 4): def f(): return i*i fs.append(f) return fsf1, f2, f3 = count() 你可能认为调用f1()，f2()和f3()结果应该是1，4，9，但实际结果全部都是 9。原因就是当count()函数返回了3个函数时，这3个函数所引用的变量 i 的值已经变成了3。由于f1、f2、f3并没有被调用，所以，此时他们并未计算 ii，当 f1 被调用时：即为3 3。 应修改为：12345678910111213def count(): fs = [] for i in range(1, 4): def f(j): #它可以正确地返回一个闭包g，g所引用的变量j不是循环变量，因此将正常执行。避免引用循环变量i def g(): return j*j return g r = f(i) fs.append(r) return fsf1, f2, f3 = count()print f1(), f2(), f3() python中匿名函数高阶函数可以接收函数做参数，有些时候，我们不需要显式地定义函数，直接传入匿名函数更方便。在Python中，对匿名函数提供了有限支持。还是以map()函数为例，计算 f(x)=x2 时，除了定义一个f(x)的函数外，还可以直接传入匿名函数：12&gt;&gt;&gt; map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9])[1, 4, 9, 16, 25, 36, 49, 64, 81] 通过对比可以看出，匿名函数 lambda x: x * x 实际上就是：12def f(x): return x * x 关键字lambda 表示匿名函数，冒号前面的 x 表示函数参数。匿名函数有个限制，就是只能有一个表达式，不写return，返回值就是该表达式的结果。使用匿名函数，可以不必定义函数名，直接创建一个函数对象，很多时候可以简化代码：123&gt;&gt;&gt; sorted([1, 3, 9, 5, 0], lambda x,y: -cmp(x,y))[9, 5, 3, 1, 0]` 12345def is_not_empty(s): return s and len(s.strip()) &gt; 0filter(is_not_empty, ['test', None, '', 'str', ' ', 'END'])print filter(lambda s: s and len(s.strip())&gt;0, ['test', None, '', 'str', ' ', 'END']) python中decorator装饰器-无参数装饰器讲解 Python的 decorator 本质上就是一个高阶函数，它接收一个函数作为参数，然后，返回一个新函数。使用 decorator 用Python提供的 @ 语法，这样可以避免手动编写 f = decorate(f) 这样的代码。123456考察一个@log的定义：可以用在任何参数只有一个的函数上，效果就是打印出“call 该函数名”def log(f): def fn(x): print 'call ' + f.__name__ + '()...' return f(x) return fn 但是，对于参数不是一个的函数，调用将报错：因为 add() 函数需要传入两个参数，但是 @log 写死了只含一个参数的返回函数。要让 @log 自适应任何参数定义的函数，可以利用Python的 *args 和 **kw，保证任意个数的参数总是能正常调用：12345def log(f): def fn(*args, **kw): print 'call ' + f.__name__ + '()...' return f(*args, **kw) return fn 现在，对于任意函数，@log 都能正常工作。 例题：请编写一个@performance，它可以打印出函数调用的时间。计算函数调用的时间可以记录调用前后的当前时间戳，然后计算两个时间戳的差。1234567891011121314import timedef performance(f): def fn(*args, **kw): t1 = time.time() r = f(*args, **kw) # f即为要被执行的函数， 也是要被装饰的函数 t2 = time.time() print 'call %s() in %fs' % (f.__name__, (t2 - t1)) return r return fn@performancedef factorial(n): return reduce(lambda x,y: x*y, range(1, n+1))print factorial(10) python中decorator装饰器-带参数考察上一节的 @log 装饰器：发现对于被装饰的函数，log打印的语句是不能变的（除了函数名）。如果有的函数非常重要，希望打印出’[INFO] call xxx()…’，有的函数不太重要，希望打印出’[DEBUG] call xxx()…’，这时，log函数本身就需要传入’INFO’或’DEBUG’这样的参数，类似这样：12345@log('DEBUG')def my_func(): pass#把上面的定义翻译成高阶函数的调用，就是：my_func = log('DEBUG')(my_func) 所以，带参数的log函数首先返回一个decorator函数，再让这个decorator函数接收my_func并返回新函数：123456789101112131415def log(prefix): def log_decorator(f): def wrapper(*args, **kw): print '[%s] %s()...' % (prefix, f.__name__) return f(*args, **kw) return wrapper return log_decorator@log('DEBUG')def test(): passprint test()#执行结果[DEBUG] test()...None 任务：上一节的@performance只能打印秒，请给 @performace 增加一个参数，允许传入’s’或’ms’：@performance(‘ms’)def factorial(n): return reduce(lambda x,y: x*y, range(1, n+1))12345678910111213141516171819import timedef performance(unit): def perf_decorator(f): def wrapper(*args, **kw): t1 = time.time() r = f(*args, **kw) t2 = time.time() t = (t2 - t1) * 1000 if unit=='ms' else (t2-t1) print 'call %s() in %f %s' % (f.__name__, t, unit) return r return wrapper return perf_decorator@performance('ms')def factorial(n): return reduce(lambda x,y: x*y, range(1, n+1))print factorial(10) python中完善decorator完善decorator@decorator可以动态实现函数功能的增加，但是，经过 @decorator “改造”后的函数，和原函数相比，除了功能多一点外，有没有其它不同的地方？可见，由于decorator返回的新函数函数名已经不是‘f2’，而是@log内部定义的‘wrapper’。这对于那些依赖函数名的代码就会失效。 decorator 还改变了函数的doc等其它属性。如果要让调用者看不出一个函数经过了@decorator的“改造”，就需要把原函数的一些属性复制到新函数中：1234567def log(f): def wrapper(*args, **kw): print 'call...' return f(*args, **kw) wrapper.__name__ = f.__name__ wrapper.__doc__ = f.__doc__ return wrapper 这样写decorator很不方便，因为我们也很难把原函数的所有必要属性都一个一个复制到新函数上，所以Python内置的functools可以用来自动化完成这个“复制”的任务：1234567import functoolsdef log(f): @functools.wraps(f) def wrapper(*args, **kw): print 'call...' return f(*args, **kw) return wrapper 注意@functools.wraps应该作用在返回的新函数上 python中偏函数当一个函数有很多参数时，调用者就需要提供多个参数。如果减少参数个数，就可以简化调用者的负担。int()函数还提供额外的base参数，默认值为10。如果传入base参数，就可以做 N 进制的转换：假设要转换大量的二进制字符串，每次都传入int(x, base=2)非常麻烦，于是，我们想到，可以定义一个 int2() 的函数，默认把 base=2 传进去：12def int2(x, base=2): return int(x, base) functools.partial就是帮助我们创建一个偏函数的，不需要我们自己定义int2()，可以直接使用下面的代码创建一个新的函数int2：1234&gt;&gt;&gt; import functools&gt;&gt;&gt; int2 = functools.partial(int, base=2)&gt;&gt;&gt; int2('1000000')64 所以，functools.partial可以把一个参数多的函数变成一个参数少的新函数，少的参数需要在创建时指定默认值，这样，新函数调用的难度就降低了。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python基础语法重点]]></title>
    <url>%2F2018%2F12%2F05%2Fpython%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E9%87%8D%E7%82%B9%2F</url>
    <content type="text"><![CDATA[用一周学习完Python的基础语法知识以后，再回头浏览一遍语法知识，将一些python独有的和容易被疏漏的初级知识总结在这里。 @TOC 目录Python中Unicode字符串如果一个字符串包含很多需要转义的字符，对每一个字符都进行转义会很麻烦。为了避免这种情况，我们可以在字符串前面加个前缀 r ，表示这是一个 raw 字符串，里面的字符就不需要转义了。例如： 1r&apos;\(~_~)/ \(~_~)/&apos; 如果字符串既包含’又包含”怎么办？ 这个时候，就需要对字符串的某些特殊字符进行“转义”，Python字符串用\进行转义。要表示字符串 Bob said “I’m OK”.由于 ‘ 和 “ 会引起歧义，因此，我们在它前面插入一个\表示这是一个普通字符，不代表字符串的起始，因此，这个字符串又可以表示为 1&apos;Bob said \&quot;I\&apos;m OK\&quot;.&apos; Python中Unicode字符串Python在后来添加了对Unicode的支持，以Unicode表示的字符串用u’…’表示，比如： print u&apos;中文&apos; 中文 如果中文字符串在Python环境下遇到 UnicodeDecodeError，这是因为 .py文件保存的格式有问题。可以在第一行添加注释 # -*- coding: utf-8 -*- 目的是告诉Python解释器，用UTF-8编码读取源代码。然后用Notepad++ 另存为… 并选择UTF-8格式保存。 Python中布尔类型在Python中，布尔类型还可以与其他数据类型做 and、or和not运算，请看下面的代码： a = True print a and &apos;a=T&apos; or &apos;a=F&apos; 计算结果不是布尔类型，而是字符串 ‘a=T’，这是为什么呢？因为Python把0、空字符串’’和None看成 False，其他数值和非空字符串都看成 True，所以：True and ‘a=T’ 计算结果是 ‘a=T’继续计算 ‘a=T’ or ‘a=F’ 计算结果还是 ‘a=T’ Python之创建tuple因为()既可以表示tuple，又可以作为括号表示运算时的优先级，结果 (1) 被Python解释器计算出结果 1，导致我们得到的不是tuple，而是整数 1。正是因为用()定义单元素的tuple有歧义，所以 Python 规定，单元素 tuple 要多加一个逗号“,”，这样就避免了歧义： &gt;&gt;&gt; t = (1,) &gt;&gt;&gt; print t (1,) Python在打印单元素tuple时，也自动添加了一个“,”，为了更明确地告诉你这是一个tuple。 Python之“可变”的tupletuple一开始指向的list并没有改成别的list，所以，tuple所谓的“不变”是说，tuple的每个元素，指向永远不变。即指向’a’，就不能改成指向’b’，指向一个list，就不能改成指向其他对象，但指向的这个list本身是可变的！理解了“指向不变”后，要创建一个内容也不变的tuple怎么做？那就必须保证tuple的每一个元素本身也不能变。 Python之 if-elif-else要避免嵌套结构的 if … else …，我们可以用 ==if … 多个elif … else …== 的结构，一次写完所有的规则： if age &gt;= 18: print &apos;adult&apos; elif age &gt;= 6: print &apos;teenager&apos; elif age &gt;= 3: print &apos;kid&apos; else: print &apos;baby&apos; ==elif== 意思就是 ==else if==。这样一来，我们就写出了结构非常清晰的一系列条件判断。 Python之什么是dictdict的第一个特点是==查找速度快==，无论dict有10个元素还是10万个元素，查找速度都一样。 而list的查找速度随着元素增加而逐渐下降。dict的第二个特点就是存储的key-value序对是==没有顺序==的！ 这和list不一样： 打印的顺序不一定是我们创建时的顺序，而且，不同的机器打印的顺序都可能不同，这说明dict内部是无序的，不能用dict存储有序的集合。dict的第三个特点是作为 key 的元素必须==不可变==，Python的基本类型如字符串str、整数int、浮点数float 都是不可变的，都可以作为 key。但是list是可变的，就不能作为 key。 不可变这个限制仅作用于key，value是否可变无所谓： { &apos;123&apos;: [1, 2, 3], # key 是 str，value是list 123: &apos;123&apos;, # key 是 int，value 是 str (&apos;a&apos;, &apos;b&apos;): True # key 是 tuple，并且tuple的每个元素都是不可变对象，value是 boolean } 最常用的key还是字符串，因为用起来最方便。 Python中 什么是setdict的作用是建立一组 key 和一组 value 的映射关系，dict的key是不能重复的。有的时候，我们只想要 dict 的 key，不关心 key 对应的 value，目的就是保证这个集合的元素不会重复，这时，set就派上用场了。set 持有一系列元素，这一点和 list 很像，但是set的元素没有重复，而且是无序的，这点和 dict 的 key很像。创建 set 的方式是调用 set() 并传入一个 list，list的元素将作为set的元素： &gt;&gt;&gt; s = set([&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]) 由于set存储的是无序集合，所以我们没法通过索引来访问。访问 set中的某个元素实际上就是判断一个元素是否在set中。例如，存储了班里同学名字的set： &gt;&gt;&gt; s = set([&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Paul&apos;]) 我们可以用 in 操作符判断：Bart是该班的同学吗？ &gt;&gt;&gt; &apos;Bart&apos; in s True 看来大小写很重要，’Bart’ 和 ‘bart’被认为是两个不同的元素。 set的内部结构和dict很像，唯一区别是不存储value，因此，判断一个元素是否在set中速度很快。set存储的元素和dict的key类似，必须是不变对象，因此，任何可变对象是不能放入set中的。最后，==set存储的元素也是没有顺序的==。 Python函数之返回多值这样我们就可以同时获得返回值： &gt;&gt;&gt; x, y = move(100, 100, 60, math.pi / 6) &gt;&gt;&gt; print x, y 151.961524227 70.0 但其实这只是一种假象，Python函数返回的仍然是单一值： &gt;&gt;&gt; r = move(100, 100, 60, math.pi / 6) &gt;&gt;&gt; print r (151.96152422706632, 70.0) 用print打印返回结果，原来返回值是一个tuple！但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。 ==使用递归函数需要注意防止栈溢出==。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。可以试试计算 fact(10000)。 Python之定义默认参数定义函数的时候，还可以有默认参数。例如Python自带的 int() 函数，其实就有两个参数，我们既可以传一个参数，又可以传两个参数： &gt;&gt;&gt; int(&apos;123&apos;) 123 &gt;&gt;&gt; int(&apos;123&apos;, 8) 83 int()函数的第二个参数是转换进制，如果不传，默认是十进制 (base=10)，如果传了，就用传入的参数。可见，函数的默认参数的作用是简化调用，你只需要把必须的参数传进去。但是在需要的时候，又可以传入额外的参数来覆盖默认参数值。 Python之定义可变参数如果想让一个函数能接受任意个参数，我们就可以定义一个可变参数： def fn(*args): print args 可变参数的名字前面有个*号，我们可以传入0个、1个或多个参数给可变参数：可变参数也不是很神秘，Python解释器会把传入的一组参数组装成一个tuple传递给可变参数，因此，在函数内部，直接把变量 args看成一个 tuple 就好了。 tuple: 创建tuple和创建list唯一不同之处是用( )替代了[ ]。现在，这个 t 就不能改变了，tuple没有 append()方法，也没有insert()和pop()方法。所以，新同学没法直接往 tuple 中添加，老同学想退出 tuple 也不行。 对list进行切片对这种经常取指定索引范围的操作，用循环十分繁琐，因此，Python提供了切片（Slice）操作符，能大大简化这种操作。对应上面的问题，取前3个元素，用一行代码就可以完成切片： `&gt;&gt;&gt; L[0:3] [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;]` L[0:3]表示，从索引0开始取，直到索引3为止，但不包括索引3。即索引0，1，2，正好是3个元素。如果第一个索引是0，还可以省略： &gt;&gt;&gt; L[:3] [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;] 也可以从索引1开始，取出2个元素出来： &gt;&gt;&gt; L[1:3] [&apos;Lisa&apos;, &apos;Bart&apos;] 只用一个 : ，表示从头到尾： &gt;&gt;&gt; L[:] &apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Paul&apos;] 因此，L[:]实际上复制出了一个新list。切片操作还可以指定第三个参数： &gt;&gt;&gt; L[::2] [&apos;Adam&apos;, &apos;Bart&apos;] 第三个参数表示每N个取一个，上面的 L[::2] 会每两个元素取出一个来，也就是隔一个取一个。把list换成tuple，切片操作完全相同，只是切片的结果也变成了tuple。 索引迭代Python中，迭代永远是取出元素本身，而非元素的索引。对于有序集合，元素确实是有索引的。有的时候，我们确实想在 for 循环中拿到索引，怎么办？ 方法是使用 ==enumerate() 函数==： &gt;&gt;&gt; L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Paul&apos;] &gt;&gt;&gt; for index, name in enumerate(L): ... print index, &apos;-&apos;, name ... 0 - Adam 1 - Lisa 2 - Bart 3 - Paul 使用 enumerate() 函数，我们可以在for循环中同时绑定索引index和元素name。但是，这不是 enumerate() 的特殊语法。实际上，enumerate() 函数把： [‘Adam’, ‘Lisa’, ‘Bart’, ‘Paul’]变成了类似： [(0, ‘Adam’), (1, ‘Lisa’), (2, ‘Bart’), (3, ‘Paul’)]因此，迭代的每一个元素实际上是一个tuple： for t in enumerate(L): index = t[0] name = t[1] print index, &apos;-&apos;, name 如果我们知道每个tuple元素都包含两个元素，for循环又可以进一步简写为： for index, name in enumerate(L): print index, &apos;-&apos;, name 这样不但代码更简单，而且还少了两条赋值语句。 可见，索引迭代也不是真的按索引访问，而是由 enumerate() 函数自动把每个元素变成 (index, element) 这样的tuple，再迭代，就同时获得了索引和元素本身。 zip()函数可以把两个 list 变成一个 list： &gt;&gt;&gt; zip([10, 20, 30], [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]) [(10, &apos;A&apos;), (20, &apos;B&apos;), (30, &apos;C&apos;)] 在迭代 [‘Adam’, ‘Lisa’, ‘Bart’, ‘Paul’] 时，如果我们想打印出名次 - 名字（名次从1开始)，请考虑如何在迭代中打印出来。 L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Paul&apos;] for index, name in zip(range(1, len(L)+1), L): print index, &apos;-&apos;, name 迭代dict的value如果我们希望迭代 dict 对象的value，应该怎么做？dict 对象有一个 values() 方法，这个方法把dict转换成一个包含所有value的list，这样，我们迭代的就是 dict的每一个 value：如果仔细阅读Python的文档，还可以发现，dict除了 values() 方法外，还有一个 itervalues() 方法，用 itervalues() 方法替代 values() 方法，迭代效果完全一样：那这两个方法有何不同之处呢？ values() 方法实际上把一个 dict 转换成了包含 value 的list。 但是 itervalues() 方法不会转换，它会在迭代过程中依次从 dict 中取出 value，所以 itervalues() 方法比 values() 方法节省了生成 list 所需的内存。 打印 itervalues() 发现它返回一个 对象，这说明在Python中，for 循环可作用的迭代对象远不止 list，tuple，str，unicode，dict等，任何可迭代对象都可以作用于for循环，而内部如何迭代我们通常并不用关心。如果一个对象说自己可迭代，那我们就直接用 for 循环去迭代它，可见，迭代是一种抽象的数据操作，它不对迭代对象内部的数据有任何要求。 迭代dict的key和value我们了解了如何迭代 dict 的key和value，那么，在一个 for 循环中，能否同时迭代 key和value？答案是肯定的。首先，我们看看 dict 对象的 items() 方法返回的值： &gt;&gt;&gt; d = { &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59 } &gt;&gt;&gt; print d.items() [(&apos;Lisa&apos;, 85), (&apos;Adam&apos;, 95), (&apos;Bart&apos;, 59)] 可以看到，items() 方法把dict对象转换成了包含tuple的list，我们对这个list进行迭代，可以同时获得key和value：和 values() 有一个 itervalues() 类似， items() 也有一个对应的 iteritems()，iteritems() 不把dict转换成list，而是在迭代过程中不断给出 tuple，所以， iteritems() 不占用额外的内存。 列表生成式如果要生成[1x1, 2x2, 3x3, …, 10x10]怎么做？方法一是循环： &gt;&gt;&gt; L = [] &gt;&gt;&gt; for x in range(1, 11): ... L.append(x * x) 但是循环太繁琐，而列表生成式则可以用一行语句代替循环生成上面的list： &gt;&gt;&gt; [x * x for x in range(1, 11)] [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 这种写法就是Python特有的列表生成式。利用列表生成式，可以以非常简洁的代码生成 list。写列表生成式时，把要生成的元素 x * x 放到前面，后面跟 for 循环，就可以把list创建出来，十分有用，多写几次，很快就可以熟悉这种语法。 复杂表达式完全可以通过一个复杂的列表生成式把它变成一个 HTML 表格： tds = [&apos;&lt;tr&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;/tr&gt;&apos; % (name, score) for name, score in d.iteritems()] 注：字符串可以通过%进行格式化，用指定的参数替代 %s。字符串的join()方法可以把一个 list 拼接成一个字符串。 条件过滤列表生成式的 for 循环后面还可以加上 if 判断。例如： &gt;&gt;&gt; [x * x for x in range(1, 11)] [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>编程</tag>
      </tags>
  </entry>
</search>
